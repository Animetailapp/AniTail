From f340b5b1d0ca2bdb513b947e6874e58b335439c0 Mon Sep 17 00:00:00 2001
From: mostafaalagamy <mostafaalagamy@email.com>
Date: Tue, 10 Feb 2026 21:09:37 +0000
Subject: [PATCH 1/5] feat: Add music recognition feature

Integrate Shazam-based music recognition with native audio fingerprinting.

Features:
- Long press on search tab (NavigationBar/NavigationRail) to open recognition screen
- Real-time audio recording with visual feedback
- Shazam API integration for music identification
- Recognition history with local database storage
- Native fingerprinting library (vibra_fp) using FFTW

Technical changes:
- Add shazamkit module for Shazam API integration
- Add vibra_fp native library for audio fingerprinting
- Add FFTW build step in GitHub Actions
- Add recognition database entities and DAO methods
- Add RecognitionScreen and RecognitionHistoryScreen

Credits:
Based on the original MusicRecognizer project by Aleksey Saenko
Original project: https://github.com/aleksey-saenko/MusicRecognizer
---
 .github/actions/setup-fftw/action.yml         |  82 +++
 .github/workflows/build.yml                   |   6 +
 .github/workflows/build_pr.yml                |   3 +
 .github/workflows/build_quick.yml             |   3 +
 .github/workflows/release.yml                 |   3 +
 README.md                                     |   2 +
 app/build.gradle.kts                          |  36 +
 app/proguard-rules.pro                        |   7 +
 app/src/main/AndroidManifest.xml              |   4 +
 app/src/main/cpp/vibrafp/README.md            |  40 ++
 app/src/main/cpp/vibrafp/include/vibra.h      |  99 +++
 app/src/main/cpp/vibrafp/lib/CMakeLists.txt   | 126 ++++
 .../cpp/vibrafp/lib/algorithm/frequency.cpp   |  28 +
 .../cpp/vibrafp/lib/algorithm/frequency.h     |  45 ++
 .../cpp/vibrafp/lib/algorithm/signature.cpp   |  98 +++
 .../cpp/vibrafp/lib/algorithm/signature.h     |  80 +++
 .../lib/algorithm/signature_generator.cpp     | 211 ++++++
 .../lib/algorithm/signature_generator.h       |  49 ++
 .../main/cpp/vibrafp/lib/audio/byte_control.h |  29 +
 .../cpp/vibrafp/lib/audio/downsampler.cpp     | 179 +++++
 .../main/cpp/vibrafp/lib/audio/downsampler.h  |  55 ++
 app/src/main/cpp/vibrafp/lib/audio/wav.cpp    | 109 +++
 app/src/main/cpp/vibrafp/lib/audio/wav.h      |  90 +++
 app/src/main/cpp/vibrafp/lib/utils/base64.h   |  55 ++
 app/src/main/cpp/vibrafp/lib/utils/crc32.h    |  28 +
 app/src/main/cpp/vibrafp/lib/utils/fft.h      |  78 ++
 app/src/main/cpp/vibrafp/lib/utils/hanning.h  | 348 +++++++++
 .../main/cpp/vibrafp/lib/utils/ring_buffer.h  |  69 ++
 app/src/main/cpp/vibrafp/lib/vibra.cpp        |  67 ++
 app/src/main/cpp/vibrafp/lib/vibra.sym        |   6 +
 app/src/main/cpp/vibrafp/lib/vibra_jni.cpp    |  67 ++
 .../vibrafp/third_party/build-fftw-android.sh | 263 +++++++
 .../com/metrolist/music/MainActivity.kt       |  20 +-
 .../com/metrolist/music/db/DatabaseDao.kt     |  32 +
 .../com/metrolist/music/db/MusicDatabase.kt   |   7 +-
 .../music/db/entities/RecognitionHistory.kt   |  40 ++
 .../music/recognition/AudioResampler.kt       | 114 +++
 .../recognition/MusicRecognitionService.kt    | 176 +++++
 .../music/recognition/VibraSignature.kt       |  24 +
 .../music/ui/component/AppNavigation.kt       |  34 +-
 .../music/ui/component/HideOnScrollFAB.kt     | 110 ++-
 .../metrolist/music/ui/screens/HomeScreen.kt  |   3 +
 .../music/ui/screens/NavigationBuilder.kt     |  10 +
 .../recognition/RecognitionHistoryScreen.kt   | 255 +++++++
 .../screens/recognition/RecognitionScreen.kt  | 680 ++++++++++++++++++
 app/src/main/res/drawable/mic.xml             |   9 +
 app/src/main/res/values/metrolist_strings.xml |  18 +
 settings.gradle.kts                           |   1 +
 shazamkit/build.gradle.kts                    |  18 +
 .../kotlin/com/metrolist/shazamkit/Shazam.kt  | 145 ++++
 .../shazamkit/models/ShazamModels.kt          | 317 ++++++++
 51 files changed, 4350 insertions(+), 28 deletions(-)
 create mode 100644 .github/actions/setup-fftw/action.yml
 create mode 100644 app/src/main/cpp/vibrafp/README.md
 create mode 100644 app/src/main/cpp/vibrafp/include/vibra.h
 create mode 100644 app/src/main/cpp/vibrafp/lib/CMakeLists.txt
 create mode 100644 app/src/main/cpp/vibrafp/lib/algorithm/frequency.cpp
 create mode 100644 app/src/main/cpp/vibrafp/lib/algorithm/frequency.h
 create mode 100644 app/src/main/cpp/vibrafp/lib/algorithm/signature.cpp
 create mode 100644 app/src/main/cpp/vibrafp/lib/algorithm/signature.h
 create mode 100644 app/src/main/cpp/vibrafp/lib/algorithm/signature_generator.cpp
 create mode 100644 app/src/main/cpp/vibrafp/lib/algorithm/signature_generator.h
 create mode 100644 app/src/main/cpp/vibrafp/lib/audio/byte_control.h
 create mode 100644 app/src/main/cpp/vibrafp/lib/audio/downsampler.cpp
 create mode 100644 app/src/main/cpp/vibrafp/lib/audio/downsampler.h
 create mode 100644 app/src/main/cpp/vibrafp/lib/audio/wav.cpp
 create mode 100644 app/src/main/cpp/vibrafp/lib/audio/wav.h
 create mode 100644 app/src/main/cpp/vibrafp/lib/utils/base64.h
 create mode 100644 app/src/main/cpp/vibrafp/lib/utils/crc32.h
 create mode 100644 app/src/main/cpp/vibrafp/lib/utils/fft.h
 create mode 100644 app/src/main/cpp/vibrafp/lib/utils/hanning.h
 create mode 100644 app/src/main/cpp/vibrafp/lib/utils/ring_buffer.h
 create mode 100644 app/src/main/cpp/vibrafp/lib/vibra.cpp
 create mode 100644 app/src/main/cpp/vibrafp/lib/vibra.sym
 create mode 100644 app/src/main/cpp/vibrafp/lib/vibra_jni.cpp
 create mode 100644 app/src/main/cpp/vibrafp/third_party/build-fftw-android.sh
 create mode 100644 app/src/main/kotlin/com/metrolist/music/db/entities/RecognitionHistory.kt
 create mode 100644 app/src/main/kotlin/com/metrolist/music/recognition/AudioResampler.kt
 create mode 100644 app/src/main/kotlin/com/metrolist/music/recognition/MusicRecognitionService.kt
 create mode 100644 app/src/main/kotlin/com/metrolist/music/recognition/VibraSignature.kt
 create mode 100644 app/src/main/kotlin/com/metrolist/music/ui/screens/recognition/RecognitionHistoryScreen.kt
 create mode 100644 app/src/main/kotlin/com/metrolist/music/ui/screens/recognition/RecognitionScreen.kt
 create mode 100644 app/src/main/res/drawable/mic.xml
 create mode 100644 shazamkit/build.gradle.kts
 create mode 100644 shazamkit/src/main/kotlin/com/metrolist/shazamkit/Shazam.kt
 create mode 100644 shazamkit/src/main/kotlin/com/metrolist/shazamkit/models/ShazamModels.kt

diff --git a/.github/actions/setup-fftw/action.yml b/.github/actions/setup-fftw/action.yml
new file mode 100644
index 0000000000..c6a90d834b
--- /dev/null
+++ b/.github/actions/setup-fftw/action.yml
@@ -0,0 +1,82 @@
+name: 'Setup FFTW for Android'
+description: 'Build and cache FFTW static libraries for Android ABIs'
+
+inputs:
+  ndk-version:
+    description: 'Android NDK version'
+    required: false
+    default: '27.0.12077973'
+  fftw-version:
+    description: 'FFTW version to build'
+    required: false
+    default: '3.3.10'
+  api-level:
+    description: 'Android API level'
+    required: false
+    default: '26'
+
+runs:
+  using: 'composite'
+  steps:
+    - name: Cache FFTW libraries
+      id: cache-fftw
+      uses: actions/cache@v4
+      with:
+        path: app/src/main/cpp/vibrafp/third_party/fftw-android
+        key: fftw-${{ inputs.fftw-version }}-ndk-${{ inputs.ndk-version }}-api-${{ inputs.api-level }}
+
+    - name: Build FFTW for Android
+      if: steps.cache-fftw.outputs.cache-hit != 'true'
+      shell: bash
+      env:
+        NDK_VERSION: ${{ inputs.ndk-version }}
+        FFTW_VERSION: ${{ inputs.fftw-version }}
+        API: ${{ inputs.api-level }}
+        OUT_BASE: app/src/main/cpp/vibrafp/third_party/fftw-android
+      run: |
+        # Find the correct NDK path
+        if [ -d "$ANDROID_NDK_HOME" ]; then
+          NDK_PATH="$ANDROID_NDK_HOME"
+        elif [ -d "$ANDROID_NDK" ]; then
+          NDK_PATH="$ANDROID_NDK"
+        elif [ -d "$ANDROID_SDK_ROOT/ndk/$NDK_VERSION" ]; then
+          NDK_PATH="$ANDROID_SDK_ROOT/ndk/$NDK_VERSION"
+        elif [ -d "/usr/local/lib/android/sdk/ndk/$NDK_VERSION" ]; then
+          NDK_PATH="/usr/local/lib/android/sdk/ndk/$NDK_VERSION"
+        else
+          # List available NDK versions
+          echo "Looking for NDK..."
+          if [ -d "$ANDROID_SDK_ROOT/ndk" ]; then
+            echo "Available NDK versions in $ANDROID_SDK_ROOT/ndk:"
+            ls -la "$ANDROID_SDK_ROOT/ndk/" || true
+          fi
+          if [ -d "/usr/local/lib/android/sdk/ndk" ]; then
+            echo "Available NDK versions in /usr/local/lib/android/sdk/ndk:"
+            ls -la "/usr/local/lib/android/sdk/ndk/" || true
+            # Use any available NDK version
+            NDK_PATH=$(find /usr/local/lib/android/sdk/ndk -maxdepth 1 -type d -name "[0-9]*" | head -1)
+          fi
+        fi
+
+        if [ -z "$NDK_PATH" ] || [ ! -d "$NDK_PATH" ]; then
+          echo "ERROR: Could not find Android NDK"
+          exit 1
+        fi
+
+        echo "Using NDK at: $NDK_PATH"
+        cd app/src/main/cpp/vibrafp/third_party
+        chmod +x build-fftw-android.sh
+        ./build-fftw-android.sh --ndk "$NDK_PATH" --out "$GITHUB_WORKSPACE/$OUT_BASE" --version "$FFTW_VERSION" --api "$API"
+        
+    - name: Verify FFTW installation
+      shell: bash
+      run: |
+        echo "FFTW installation:"
+        ls -la app/src/main/cpp/vibrafp/third_party/fftw-android/ || echo "fftw-android directory not found"
+        for abi in arm64-v8a armeabi-v7a x86_64 x86; do
+          if [ -f "app/src/main/cpp/vibrafp/third_party/fftw-android/$abi/lib/libfftw3.a" ]; then
+            echo "✓ $abi: libfftw3.a found"
+          else
+            echo "✗ $abi: libfftw3.a NOT found"
+          fi
+        done
diff --git a/.github/workflows/build.yml b/.github/workflows/build.yml
index 6ac4840a78..246f6f1bf4 100644
--- a/.github/workflows/build.yml
+++ b/.github/workflows/build.yml
@@ -46,6 +46,9 @@ jobs:
       - name: Setup and Generate Protobuf
         uses: ./.github/actions/setup-protobuf
 
+      - name: Setup FFTW for Android
+        uses: ./.github/actions/setup-fftw
+
       - name: Grant execute permission for gradlew
         run: chmod +x gradlew
 
@@ -113,6 +116,9 @@ jobs:
       - name: Setup and Generate Protobuf
         uses: ./.github/actions/setup-protobuf
 
+      - name: Setup FFTW for Android
+        uses: ./.github/actions/setup-fftw
+
       - name: Grant execute permission for gradlew
         run: chmod +x gradlew
 
diff --git a/.github/workflows/build_pr.yml b/.github/workflows/build_pr.yml
index 7ca1aad852..2fe13013a2 100644
--- a/.github/workflows/build_pr.yml
+++ b/.github/workflows/build_pr.yml
@@ -29,6 +29,9 @@ jobs:
       - name: Setup and Generate Protobuf
         uses: ./.github/actions/setup-protobuf
 
+      - name: Setup FFTW for Android
+        uses: ./.github/actions/setup-fftw
+
       - name: Grant execute permission for gradlew
         run: chmod +x gradlew
 
diff --git a/.github/workflows/build_quick.yml b/.github/workflows/build_quick.yml
index 930c060806..7903845e05 100644
--- a/.github/workflows/build_quick.yml
+++ b/.github/workflows/build_quick.yml
@@ -40,6 +40,9 @@ jobs:
       - name: Setup and Generate Protobuf
         uses: ./.github/actions/setup-protobuf
 
+      - name: Setup FFTW for Android
+        uses: ./.github/actions/setup-fftw
+
       - name: Grant execute permission for gradlew
         run: chmod +x gradlew
 
diff --git a/.github/workflows/release.yml b/.github/workflows/release.yml
index fa91568cc1..726c44d687 100644
--- a/.github/workflows/release.yml
+++ b/.github/workflows/release.yml
@@ -105,6 +105,9 @@ jobs:
           cd app
           bash generate_proto.sh
 
+      - name: Setup FFTW for Android
+        uses: ./.github/actions/setup-fftw
+
       - name: Grant execute permission for gradlew
         run: chmod +x gradlew
 
diff --git a/README.md b/README.md
index f5f63463fe..f527f7a2f7 100644
--- a/README.md
+++ b/README.md
@@ -184,6 +184,8 @@ Credits:
 
 [**metroserver**](https://github.com/MetrolistGroup/metroserver) – for providing us with the listen together implementation.
 
+[**MusicRecognizer**](https://github.com/aleksey-saenko/MusicRecognizer) – for the music recognition feature implementation and Shazam API integration.
+
 The open-source community for tools, libraries, and APIs that make this project possible.
 
 <sub>Thank you to all the amazing developers who made this project possible!</sub>
diff --git a/app/build.gradle.kts b/app/build.gradle.kts
index aaacaf73aa..cfa0248903 100644
--- a/app/build.gradle.kts
+++ b/app/build.gradle.kts
@@ -17,6 +17,7 @@ plugins {
 android {
     namespace = "com.metrolist.music"
     compileSdk = 36
+    ndkVersion = "27.0.12077973"
 
     defaultConfig {
         applicationId = "com.metrolist.music"
@@ -34,6 +35,18 @@ android {
 
         buildConfigField("String", "LASTFM_API_KEY", "\"$lastFmKey\"")
         buildConfigField("String", "LASTFM_SECRET", "\"$lastFmSecret\"")
+        
+        // NDK configuration for vibra_fp library
+        ndk {
+            abiFilters += listOf("arm64-v8a", "armeabi-v7a", "x86_64", "x86")
+        }
+    }
+    
+    externalNativeBuild {
+        cmake {
+            path("src/main/cpp/vibrafp/lib/CMakeLists.txt")
+            version = "3.22.1"
+        }
     }
 
     flavorDimensions += listOf("abi", "variant")
@@ -111,6 +124,17 @@ android {
                 getDefaultProguardFile("proguard-android-optimize.txt"),
                 "proguard-rules.pro"
             )
+            externalNativeBuild {
+                cmake {
+                    arguments += listOf(
+                        "-DENABLE_LTO=ON",
+                        "-DCMAKE_BUILD_TYPE=Release"
+                    )
+                }
+            }
+            ndk {
+                debugSymbolLevel = "NONE"
+            }
         }
         debug {
             applicationIdSuffix = ".debug"
@@ -120,6 +144,17 @@ android {
             } else {
                 signingConfigs.getByName("persistentDebug")
             }
+            externalNativeBuild {
+                cmake {
+                    arguments += listOf(
+                        "-DENABLE_LTO=OFF",
+                        "-DCMAKE_BUILD_TYPE=Debug"
+                    )
+                }
+            }
+            ndk {
+                debugSymbolLevel = "FULL"
+            }
         }
     }
 
@@ -251,6 +286,7 @@ dependencies {
     implementation(project(":lastfm"))
     implementation(project(":betterlyrics"))
     implementation(project(":simpmusic"))
+    implementation(project(":shazamkit"))
 
     implementation(libs.ktor.client.core)
     implementation(libs.ktor.serialization.json)
diff --git a/app/proguard-rules.pro b/app/proguard-rules.pro
index 38a41f5f7d..0bc15f485d 100644
--- a/app/proguard-rules.pro
+++ b/app/proguard-rules.pro
@@ -119,3 +119,10 @@
 
 ## JSoup re2j optional dependency
 -dontwarn com.google.re2j.**
+
+# Vibra fingerprint library
+-keep class com.metrolist.music.recognition.VibraSignature { *; }
+-keepclassmembers class com.metrolist.music.recognition.VibraSignature {
+    native <methods>;
+}
+
diff --git a/app/src/main/AndroidManifest.xml b/app/src/main/AndroidManifest.xml
index 9ad58da442..2b7df15246 100644
--- a/app/src/main/AndroidManifest.xml
+++ b/app/src/main/AndroidManifest.xml
@@ -10,6 +10,10 @@
     <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
     <uses-permission android:name="android.permission.FOREGROUND_SERVICE_MEDIA_PLAYBACK" />
     <uses-permission android:name="android.permission.FOREGROUND_SERVICE_DATA_SYNC" />
+    <uses-permission android:name="android.permission.RECORD_AUDIO" />
+
+    <!-- Microphone feature for music recognition (not required) -->
+    <uses-feature android:name="android.hardware.microphone" android:required="false" />
 
     <!-- Android TV -->
     <uses-feature android:name="android.software.leanback" android:required="false" />
diff --git a/app/src/main/cpp/vibrafp/README.md b/app/src/main/cpp/vibrafp/README.md
new file mode 100644
index 0000000000..cb9ebc7faf
--- /dev/null
+++ b/app/src/main/cpp/vibrafp/README.md
@@ -0,0 +1,40 @@
+C++ implementation of Shazam's audio fingerprinting algorithm based on Vibra (https://github.com/BayernMuller/vibra)
+
+## Building FFTW for Android
+
+This library requires FFTW3 static libraries for each Android ABI. To build them:
+
+1. Install Android NDK
+2. Run the build script:
+   ```bash
+   cd third_party
+   ANDROID_NDK_HOME=/path/to/ndk ./build-fftw-android.sh
+   ```
+3. The script will download, compile and install FFTW to `third_party/fftw-android/<abi>/`
+
+## Pre-built FFTW
+
+If you have pre-built FFTW libraries, place them in:
+```
+third_party/fftw-android/
+├── arm64-v8a/
+│   ├── include/
+│   │   └── fftw3.h
+│   └── lib/
+│       └── libfftw3.a
+├── armeabi-v7a/
+│   ├── include/
+│   │   └── fftw3.h
+│   └── lib/
+│       └── libfftw3.a
+├── x86_64/
+│   ├── include/
+│   │   └── fftw3.h
+│   └── lib/
+│       └── libfftw3.a
+└── x86/
+    ├── include/
+    │   └── fftw3.h
+    └── lib/
+        └── libfftw3.a
+```
\ No newline at end of file
diff --git a/app/src/main/cpp/vibrafp/include/vibra.h b/app/src/main/cpp/vibrafp/include/vibra.h
new file mode 100644
index 0000000000..f4c7801949
--- /dev/null
+++ b/app/src/main/cpp/vibrafp/include/vibra.h
@@ -0,0 +1,99 @@
+#ifndef INCLUDE_VIBRA_H_
+#define INCLUDE_VIBRA_H_
+
+#include <string>
+
+extern "C"
+{
+/**
+ * @brief Structure to hold a music fingerprint.
+ *
+ * @note The structure is thread-unsafe and does not require manual memory management
+ * for the returned pointer.
+ */
+struct Fingerprint
+{
+    std::string uri;        /**< The URI associated with the fingerprint. */
+    unsigned int sample_ms; /**< The sample duration in milliseconds. */
+};
+
+/**
+ * @brief Generate a fingerprint from a music file.
+ *
+ * @param music_file_path The path to the music file.
+ * @return Fingerprint* Pointer to the generated fingerprint.
+ *
+ * @note The returned pointer must be freed after use. See vibra_free_fingerprint().
+ */
+Fingerprint *vibra_get_fingerprint_from_music_file(const char *music_file_path);
+
+/**
+ * @brief Generate a fingerprint from WAV data.
+ *
+ * @param raw_wav The raw WAV data.
+ * @param wav_data_size The size of the WAV data in bytes.
+ * @return Fingerprint* Pointer to the generated fingerprint.
+ *
+ * @note The returned pointer must be freed after use. See vibra_free_fingerprint().
+ */
+Fingerprint *vibra_get_fingerprint_from_wav_data(const char *raw_wav, int wav_data_size);
+
+/**
+ * @brief Generate a fingerprint from signed PCM data.
+ *
+ * @param raw_pcm The raw PCM data.
+ * @param pcm_data_size The size of the PCM data in bytes.
+ * @param sample_rate The sample rate of the PCM data.
+ * @param sample_width The sample width (bits per sample) of the PCM data.
+ * @param channel_count The number of channels in the PCM data.
+ * @return Fingerprint* Pointer to the generated fingerprint.
+ *
+ * @note The returned pointer must be freed after use. See vibra_free_fingerprint().
+ */
+Fingerprint *vibra_get_fingerprint_from_signed_pcm(const char *raw_pcm, int pcm_data_size,
+                                                   int sample_rate, int sample_width,
+                                                   int channel_count);
+
+/**
+ * @brief Generate a fingerprint from PCM data.
+ *
+ * @param raw_pcm The raw PCM data.
+ * @param pcm_data_size The size of the PCM data in bytes.
+ * @param sample_rate The sample rate of the PCM data.
+ * @param sample_width The sample width (bits per sample) of the PCM data.
+ * @param channel_count The number of channels in the PCM data.
+ * @return Fingerprint* Pointer to the generated fingerprint.
+ *
+ * @note The returned pointer must be freed after use. See vibra_free_fingerprint().
+ */
+Fingerprint *vibra_get_fingerprint_from_float_pcm(const char *raw_pcm, int pcm_data_size,
+                                                  int sample_rate, int sample_width,
+                                                  int channel_count);
+
+/**
+ * @brief Get the URI associated with a fingerprint.
+ *
+ * @param fingerprint Pointer to the fingerprint.
+ * @return const char* The URI as a C-string.
+ *
+ * @note The returned pointer should not be freed.
+ */
+const char *vibra_get_uri_from_fingerprint(Fingerprint *fingerprint);
+
+/**
+ * @brief Get the sample duration in milliseconds from a fingerprint.
+ *
+ * @param fingerprint Pointer to the fingerprint.
+ * @return unsigned int The sample duration in milliseconds.
+ */
+unsigned int vibra_get_sample_ms_from_fingerprint(Fingerprint *fingerprint);
+
+/**
+ * @brief Free a fingerprint.
+ *
+ * @param fingerprint Pointer to the fingerprint.
+ */
+void vibra_free_fingerprint(Fingerprint *fingerprint);
+} // extern "C"
+
+#endif // INCLUDE_VIBRA_H_
diff --git a/app/src/main/cpp/vibrafp/lib/CMakeLists.txt b/app/src/main/cpp/vibrafp/lib/CMakeLists.txt
new file mode 100644
index 0000000000..090e11305e
--- /dev/null
+++ b/app/src/main/cpp/vibrafp/lib/CMakeLists.txt
@@ -0,0 +1,126 @@
+cmake_minimum_required(VERSION 3.22)
+project(vibra_fp LANGUAGES CXX)
+
+# ========== Options ==========
+option(ENABLE_LTO "Enable thin-LTO compile/link flags" ON)
+
+# Optional: user can pass -DFFTW3_PATH=/path/to/install-android-fftw
+# Expected layout if FFTW3_PATH is provided:
+#   <FFTW3_PATH>/<abi>/include/   -> headers
+#   <FFTW3_PATH>/<abi>/lib/libfftw3.a  -> static lib
+if(NOT DEFINED FFTW3_PATH)
+    set(FFTW3_PATH "" CACHE PATH "Path to FFTW install root (optional)")
+endif()
+
+message(STATUS "Project source dir: ${CMAKE_SOURCE_DIR}")
+
+# ========== Sources ==========
+set(LIBVIBRA_SOURCES
+        vibra.cpp
+        vibra_jni.cpp
+        algorithm/signature.cpp
+        algorithm/frequency.cpp
+        algorithm/signature_generator.cpp
+        audio/wav.cpp
+        audio/downsampler.cpp
+)
+
+add_library(vibra_fp SHARED ${LIBVIBRA_SOURCES})
+
+target_include_directories(vibra_fp
+        PRIVATE
+        ${CMAKE_SOURCE_DIR}/../include
+        ${CMAKE_SOURCE_DIR}
+        ${CMAKE_SOURCE_DIR}/algorithm
+        ${CMAKE_SOURCE_DIR}/audio
+        ${CMAKE_SOURCE_DIR}/utils
+)
+
+# ========== FFTW detection and import ==========
+set(FFTW3_INCLUDE_DIR "")
+set(FFTW3_STATIC_LIB "")
+
+if(FFTW3_PATH)
+    # fallback layout
+    set(FFTW3_STATIC_LIB "${FFTW3_PATH}/lib/libfftw3.a")
+    set(FFTW3_INCLUDE_DIR "${FFTW3_PATH}/include")
+    # prefer per-ABI layout if building for Android and file exists
+    if(ANDROID AND ANDROID_ABI)
+        set(CANDIDATE_LIB "${FFTW3_PATH}/${ANDROID_ABI}/lib/libfftw3.a")
+        if(EXISTS "${CANDIDATE_LIB}")
+            set(FFTW3_STATIC_LIB "${CANDIDATE_LIB}")
+            set(FFTW3_INCLUDE_DIR "${FFTW3_PATH}/${ANDROID_ABI}/include")
+        endif()
+    endif()
+endif()
+
+# If FFTW3_PATH not provided, try the repository-local default layout:
+# <CMAKE_SOURCE_DIR>/third_party/fftw-android/<ANDROID_ABI>/libfftw3.a
+if(ANDROID AND (NOT FFTW3_STATIC_LIB OR NOT EXISTS "${FFTW3_STATIC_LIB}"))
+    set(LOCAL_THIRD "${CMAKE_SOURCE_DIR}/../third_party/fftw-android")
+    if(DEFINED ANDROID_ABI)
+        set(LOCAL_LIB "${LOCAL_THIRD}/${ANDROID_ABI}/lib/libfftw3.a")
+        if(EXISTS "${LOCAL_LIB}")
+            set(FFTW3_STATIC_LIB "${LOCAL_LIB}")
+            set(FFTW3_INCLUDE_DIR "${LOCAL_THIRD}/${ANDROID_ABI}/include")
+        endif()
+    endif()
+endif()
+
+## Create an IMPORTED target
+if(FFTW3_STATIC_LIB AND EXISTS "${FFTW3_STATIC_LIB}")
+    add_library(fftw3_static STATIC IMPORTED GLOBAL)
+    set_target_properties(fftw3_static PROPERTIES
+            IMPORTED_LOCATION "${FFTW3_STATIC_LIB}"
+            INTERFACE_INCLUDE_DIRECTORIES "${FFTW3_INCLUDE_DIR}"
+    )
+    message(STATUS "Using FFTW (imported static): ${FFTW3_STATIC_LIB}")
+    target_link_libraries(vibra_fp PRIVATE fftw3_static)
+else()
+    message(FATAL_ERROR "FFTW3 static library not found. Build fftw and place prebuilt in third_party/fftw-android/<abi>.")
+endif()
+
+# ========== C++ standard ==========
+set_target_properties(vibra_fp PROPERTIES CXX_STANDARD 11 CXX_STANDARD_REQUIRED YES)
+
+# ========== Android system libs ==========
+if (ANDROID)
+    target_link_libraries(vibra_fp PRIVATE log m)
+endif()
+
+# ========== Compiler / Linker options ==========
+# Common options (Release vs Debug)
+target_compile_options(vibra_fp PRIVATE
+        $<$<CONFIG:Release>:-O2>
+        $<$<NOT:$<CONFIG:Release>>:-O0>
+        $<$<NOT:$<CONFIG:Release>>:-g>
+        $<$<CONFIG:Release>:-ffunction-sections>
+        $<$<CONFIG:Release>:-fdata-sections>
+        $<$<CONFIG:Release>:-fvisibility=hidden>
+        $<$<CONFIG:Release>:-fomit-frame-pointer>
+        $<$<CONFIG:Release>:-fPIC>
+)
+
+# Add thin-LTO flags only if requested
+if(ENABLE_LTO)
+    target_compile_options(vibra_fp PRIVATE
+            $<$<CONFIG:Release>:-flto=thin>
+    )
+    target_link_options(vibra_fp PRIVATE
+            $<$<CONFIG:Release>:-flto=thin>
+            $<$<CONFIG:Release>:-Wl,--gc-sections>
+            $<$<CONFIG:Release>:-Wl,--strip-all>
+    )
+else()
+    target_link_options(vibra_fp PRIVATE
+            $<$<CONFIG:Release>:-Wl,--gc-sections>
+            $<$<CONFIG:Release>:-Wl,--strip-all>
+    )
+endif()
+
+# ========== Limit exported symbols ==========
+set(VIBRA_EXPORT_SCRIPT "${CMAKE_SOURCE_DIR}/vibra.sym")
+if(EXISTS "${VIBRA_EXPORT_SCRIPT}")
+    message(STATUS "Using version script: ${VIBRA_EXPORT_SCRIPT}")
+    target_link_options(vibra_fp PRIVATE "-Wl,--version-script=${VIBRA_EXPORT_SCRIPT}")
+endif()
diff --git a/app/src/main/cpp/vibrafp/lib/algorithm/frequency.cpp b/app/src/main/cpp/vibrafp/lib/algorithm/frequency.cpp
new file mode 100644
index 0000000000..790f3847a2
--- /dev/null
+++ b/app/src/main/cpp/vibrafp/lib/algorithm/frequency.cpp
@@ -0,0 +1,28 @@
+#include "algorithm/frequency.h"
+#include <cmath>
+
+FrequencyPeak::FrequencyPeak(std::uint32_t fft_pass_number, std::uint32_t peak_magnitude,
+                             std::uint32_t corrected_peak_frequency_bin, std::uint32_t sample_rate)
+    : fft_pass_number_(fft_pass_number), peak_magnitude_(peak_magnitude),
+      corrected_peak_frequency_bin_(corrected_peak_frequency_bin), sample_rate_(sample_rate)
+{
+}
+
+FrequencyPeak::~FrequencyPeak()
+{
+}
+
+double FrequencyPeak::ComputeFrequency() const
+{
+    return corrected_peak_frequency_bin_ * (static_cast<double>(sample_rate_) / 2. / 1024. / 64.);
+}
+
+double FrequencyPeak::ComputeAmplitudePCM() const
+{
+    return std::sqrt(std::exp((peak_magnitude_ - 6144) / 1477.3) * (1 << 17) / 2.) / 1024.;
+}
+
+double FrequencyPeak::ComputeElapsedSeconds() const
+{
+    return static_cast<double>(fft_pass_number_) * 128. / static_cast<double>(sample_rate_);
+}
diff --git a/app/src/main/cpp/vibrafp/lib/algorithm/frequency.h b/app/src/main/cpp/vibrafp/lib/algorithm/frequency.h
new file mode 100644
index 0000000000..fd87b8a36e
--- /dev/null
+++ b/app/src/main/cpp/vibrafp/lib/algorithm/frequency.h
@@ -0,0 +1,45 @@
+#ifndef LIB_ALGORITHM_FREQUENCY_H_
+#define LIB_ALGORITHM_FREQUENCY_H_
+
+#include <cstdint>
+
+enum class FrequencyBand
+{
+    _0_150 = -1,
+    _250_520,
+    _520_1450,
+    _1450_3500,
+    _3500_5500,
+};
+
+class FrequencyPeak
+{
+public:
+    FrequencyPeak(std::uint32_t fft_pass_number, std::uint32_t peak_magnitude,
+                  std::uint32_t corrected_peak_frequency_bin, std::uint32_t sample_rate);
+    ~FrequencyPeak();
+
+    inline std::uint32_t fft_pass_number() const
+    {
+        return fft_pass_number_;
+    }
+    inline std::uint32_t peak_magnitude() const
+    {
+        return peak_magnitude_;
+    }
+    inline std::uint32_t corrected_peak_frequency_bin() const
+    {
+        return corrected_peak_frequency_bin_;
+    }
+    inline double ComputeFrequency() const;
+    inline double ComputeAmplitudePCM() const;
+    inline double ComputeElapsedSeconds() const;
+
+private:
+    std::uint32_t fft_pass_number_;
+    std::uint32_t peak_magnitude_;
+    std::uint32_t corrected_peak_frequency_bin_;
+    std::uint32_t sample_rate_;
+};
+
+#endif // LIB_ALGORITHM_FREQUENCY_H_
diff --git a/app/src/main/cpp/vibrafp/lib/algorithm/signature.cpp b/app/src/main/cpp/vibrafp/lib/algorithm/signature.cpp
new file mode 100644
index 0000000000..3f94cf474c
--- /dev/null
+++ b/app/src/main/cpp/vibrafp/lib/algorithm/signature.cpp
@@ -0,0 +1,98 @@
+#include "algorithm/signature.h"
+#include <algorithm>
+#include <sstream>
+#include <string>
+#include "utils/base64.h"
+#include "utils/crc32.h"
+
+Signature::Signature(std::uint32_t sample_rate, std::uint32_t num_samples)
+    : sample_rate_(sample_rate), num_samples_(num_samples)
+{
+}
+
+void Signature::Reset(std::uint32_t sampleRate, std::uint32_t num_samples)
+{
+    sample_rate_ = sampleRate;
+    num_samples_ = num_samples;
+    frequency_band_to_peaks_.clear();
+}
+
+std::uint32_t Signature::SumOfPeaksLength() const
+{
+    std::uint32_t sum = 0;
+    for (const auto &pair : frequency_band_to_peaks_)
+    {
+        sum += pair.second.size();
+    }
+    return sum;
+}
+
+std::string Signature::EncodeBase64() const
+{
+    RawSignatureHeader header = {};
+    header.magic1 = 0xcafe2580;
+    header.magic2 = 0x94119c00;
+    header.shifted_sample_rate_id = 3 << 27;
+    header.fixed_value = ((15 << 19) + 0x40000);
+    header.number_samples_plus_divided_sample_rate =
+        static_cast<std::uint32_t>(num_samples_ + sample_rate_ * 0.24);
+    std::stringstream contents;
+    for (const auto &pair : frequency_band_to_peaks_)
+    {
+        const auto &band = pair.first;
+        const auto &peaks = pair.second;
+
+        std::stringstream peak_buf;
+        std::size_t fft_pass_number = 0;
+
+        for (const auto &peak : peaks)
+        {
+            if (peak.fft_pass_number() - fft_pass_number >= 255)
+            {
+                peak_buf << "\xff";
+                write_little_endian(peak_buf, peak.fft_pass_number());
+                fft_pass_number = peak.fft_pass_number();
+            }
+
+            peak_buf << static_cast<char>(peak.fft_pass_number() - fft_pass_number);
+            write_little_endian(peak_buf, peak.peak_magnitude(), 2);
+            write_little_endian(peak_buf, peak.corrected_peak_frequency_bin(), 2);
+
+            fft_pass_number = peak.fft_pass_number();
+        }
+
+        write_little_endian(contents, 0x60030040u + static_cast<std::uint32_t>(band));
+        write_little_endian(contents, static_cast<std::uint32_t>(peak_buf.str().size()));
+        contents << peak_buf.str();
+
+        for (std::size_t i = 0; i < (-peak_buf.str().size() % 4); ++i)
+            contents << '\0';
+    }
+
+    header.size_minus_header = contents.str().size() + 8;
+
+    std::stringstream header_buf;
+    header_buf.write(reinterpret_cast<const char *>(&header), sizeof(header));
+
+    write_little_endian(header_buf, 0x40000000u);
+    write_little_endian(header_buf, static_cast<std::uint32_t>(contents.str().size()) + 8);
+
+    header_buf << contents.str();
+
+    const auto &header_buf_str = header_buf.str();
+    header.crc32 = crc32::crc32(header_buf_str.c_str() + 8, header_buf_str.size() - 8) & 0xffffffff;
+
+    header_buf.seekp(0);
+    header_buf.write(reinterpret_cast<const char *>(&header), sizeof(header));
+
+    std::string header_string = header_buf.str();
+
+    std::string base64_uri;
+    base64_uri += "data:audio/vnd.shazam.sig;base64,";
+    base64_uri += base64::encode(header_string.c_str(), header_string.size());
+    return base64_uri;
+}
+
+Signature::~Signature()
+{
+}
diff --git a/app/src/main/cpp/vibrafp/lib/algorithm/signature.h b/app/src/main/cpp/vibrafp/lib/algorithm/signature.h
new file mode 100644
index 0000000000..4c74f9d6a9
--- /dev/null
+++ b/app/src/main/cpp/vibrafp/lib/algorithm/signature.h
@@ -0,0 +1,80 @@
+#ifndef LIB_ALGORITHM_SIGNATURE_H_
+#define LIB_ALGORITHM_SIGNATURE_H_
+
+#include <list>
+#include <map>
+#include <memory>
+#include <sstream>
+#include <string>
+#include "algorithm/frequency.h"
+
+// Prevent Structure Padding
+#ifdef _MSC_VER
+#pragma pack(push, 1)
+#define PACKED_ATTRIBUTE
+#else
+#define PACKED_ATTRIBUTE __attribute__((packed))
+#endif
+
+struct RawSignatureHeader
+{
+    uint32_t magic1;
+    uint32_t crc32;
+    uint32_t size_minus_header;
+    uint32_t magic2;
+    uint32_t void1[3];
+    uint32_t shifted_sample_rate_id;
+    uint32_t void2[2];
+    uint32_t number_samples_plus_divided_sample_rate;
+    uint32_t fixed_value;
+} PACKED_ATTRIBUTE;
+
+#ifdef _MSC_VER
+#pragma pack(pop)
+#endif
+
+class Signature
+{
+public:
+    Signature(std::uint32_t sample_rate, std::uint32_t num_samples);
+    ~Signature();
+    void Reset(std::uint32_t sampleRate, std::uint32_t num_samples);
+
+    inline void Addnum_samples(std::uint32_t num_samples)
+    {
+        num_samples_ += num_samples;
+    }
+    inline std::uint32_t sample_rate() const
+    {
+        return sample_rate_;
+    }
+    inline std::uint32_t num_samples() const
+    {
+        return num_samples_;
+    }
+    inline std::map<FrequencyBand, std::list<FrequencyPeak>> &frequency_band_to_peaks()
+    {
+        return frequency_band_to_peaks_;
+    }
+    std::uint32_t SumOfPeaksLength() const;
+    std::string EncodeBase64() const;
+
+private:
+    template <typename T>
+    std::stringstream &write_little_endian(std::stringstream &stream, const T &&value,
+                                           size_t size = sizeof(T)) const
+    {
+        for (size_t i = 0; i < size; ++i)
+        {
+            stream << static_cast<char>(value >> (i << 3));
+        }
+        return stream;
+    }
+
+private:
+    std::uint32_t sample_rate_;
+    std::uint32_t num_samples_;
+    std::map<FrequencyBand, std::list<FrequencyPeak>> frequency_band_to_peaks_;
+};
+
+#endif // LIB_ALGORITHM_SIGNATURE_H_
diff --git a/app/src/main/cpp/vibrafp/lib/algorithm/signature_generator.cpp b/app/src/main/cpp/vibrafp/lib/algorithm/signature_generator.cpp
new file mode 100644
index 0000000000..484894fd29
--- /dev/null
+++ b/app/src/main/cpp/vibrafp/lib/algorithm/signature_generator.cpp
@@ -0,0 +1,211 @@
+#include "algorithm/signature_generator.h"
+#include <algorithm>
+#include <array>
+#include <iostream>
+#include <list>
+#include <numeric>
+#include <vector>
+#include <utility>
+#include "utils/hanning.h"
+
+SignatureGenerator::SignatureGenerator()
+    : input_pending_processing_(), sample_processed_(0), max_time_seconds_(3.1),
+      next_signature_(16000, 0), samples_ring_buffer_(FFT_BUFFER_CHUNK_SIZE, 0),
+      fft_outputs_(256, {0.0}), spread_ffts_output_(256, {0.0})
+{
+}
+
+void SignatureGenerator::FeedInput(const LowQualityTrack &input)
+{
+    input_pending_processing_.reserve(input_pending_processing_.size() + input.size());
+    input_pending_processing_.insert(input_pending_processing_.end(), input.begin(), input.end());
+}
+
+Signature SignatureGenerator::GetNextSignature()
+{
+    if (input_pending_processing_.size() - sample_processed_ < 128)
+    {
+        throw std::runtime_error("Not enough input to generate signature");
+    }
+
+    double num_samples = static_cast<double>(next_signature_.num_samples());
+    while (input_pending_processing_.size() - sample_processed_ >= 128 &&
+           (num_samples / next_signature_.sample_rate() < max_time_seconds_ ||
+            next_signature_.SumOfPeaksLength() < MAX_PEAKS))
+    {
+        LowQualityTrack input(input_pending_processing_.begin() + sample_processed_,
+                              input_pending_processing_.begin() + sample_processed_ + 128);
+
+        processInput(input);
+        sample_processed_ += 128;
+        num_samples = static_cast<double>(next_signature_.num_samples());
+    }
+
+    Signature result = std::move(next_signature_);
+    resetSignatureGenerater();
+    return result; // RVO
+}
+
+void SignatureGenerator::processInput(const LowQualityTrack &input)
+{
+    next_signature_.Addnum_samples(input.size());
+    for (std::size_t chunk = 0; chunk < input.size(); chunk += 128)
+    {
+        LowQualityTrack chunk_input(input.begin() + chunk, input.begin() + chunk + 128);
+
+        doFFT(chunk_input);
+        doPeakSpreadingAndRecoginzation();
+    }
+}
+
+void SignatureGenerator::doFFT(const LowQualityTrack &input)
+{
+    std::copy(input.begin(), input.end(),
+              samples_ring_buffer_.begin() + samples_ring_buffer_.position());
+
+    samples_ring_buffer_.position() += input.size();
+    samples_ring_buffer_.position() %= FFT_BUFFER_CHUNK_SIZE;
+    samples_ring_buffer_.num_written() += input.size();
+
+    std::vector<long double> excerpt_from_ring_buffer(FFT_BUFFER_CHUNK_SIZE, 0.0);
+
+    std::copy(samples_ring_buffer_.begin() + samples_ring_buffer_.position(),
+              samples_ring_buffer_.end(), excerpt_from_ring_buffer.begin());
+
+    std::copy(samples_ring_buffer_.begin(),
+              samples_ring_buffer_.begin() + samples_ring_buffer_.position(),
+              excerpt_from_ring_buffer.begin() + FFT_BUFFER_CHUNK_SIZE -
+                  samples_ring_buffer_.position());
+
+    for (std::size_t i = 0; i < FFT_BUFFER_CHUNK_SIZE; ++i)
+    {
+        excerpt_from_ring_buffer[i] *= HANNIG_MATRIX[i];
+    }
+
+    decltype(fft_object_)::FFTOutput real = fft_object_.RFFT(excerpt_from_ring_buffer);
+    fft_outputs_.Append(real);
+}
+
+void SignatureGenerator::doPeakSpreadingAndRecoginzation()
+{
+    doPeakSpreading();
+
+    if (spread_ffts_output_.num_written() >= 47)
+    {
+        doPeakRecognition();
+    }
+}
+
+void SignatureGenerator::doPeakSpreading()
+{
+    auto spread_last_fft = fft_outputs_[fft_outputs_.position() - 1];
+
+    for (auto position = 0u; position < decltype(fft_object_)::OUTPUT_SIZE; ++position)
+    {
+        if (position < decltype(fft_object_)::OUTPUT_SIZE - 2)
+        {
+            spread_last_fft[position] = *std::max_element(spread_last_fft.begin() + position,
+                                                          spread_last_fft.begin() + position + 3);
+        }
+
+        auto max_value = spread_last_fft[position];
+        for (auto former_fft_num : {-1, -3, -6})
+        {
+            auto &former_fft_ouput =
+                spread_ffts_output_[(spread_ffts_output_.position() + former_fft_num) %
+                                  spread_ffts_output_.size()];
+            former_fft_ouput[position] = max_value =
+                std::max(max_value, former_fft_ouput[position]);
+        }
+    }
+    spread_ffts_output_.Append(spread_last_fft);
+}
+
+void SignatureGenerator::doPeakRecognition()
+{
+    const auto &fft_minus_46 = fft_outputs_[(fft_outputs_.position() - 46) % fft_outputs_.size()];
+    const auto &fft_minus_49 =
+        spread_ffts_output_[(spread_ffts_output_.position() - 49) % spread_ffts_output_.size()];
+
+    auto other_offsets = {-53, -45, 165, 172, 179, 186, 193, 200, 214, 221, 228, 235, 242, 249};
+    for (auto bin_position = 10u; bin_position < decltype(fft_object_)::OUTPUT_SIZE - 8; ++bin_position)
+    {
+        if (fft_minus_46[bin_position] >= 1.0 / 64.0 &&
+            fft_minus_46[bin_position] >= fft_minus_49[bin_position])
+        {
+            auto max_neighbor_in_fft_minus_49 = 0.0l;
+            for (auto neighbor_offset : {-10, -7, -4, -3, 1, 2, 5, 8})
+            {
+                max_neighbor_in_fft_minus_49 = std::max(
+                    max_neighbor_in_fft_minus_49, fft_minus_49[bin_position + neighbor_offset]);
+            }
+
+            if (fft_minus_46[bin_position] > max_neighbor_in_fft_minus_49)
+            {
+                auto max_neighbor_in_other_adjacent_ffts = max_neighbor_in_fft_minus_49;
+                for (auto other_offset : other_offsets)
+                {
+                    max_neighbor_in_other_adjacent_ffts = std::max(
+                        max_neighbor_in_other_adjacent_ffts,
+                        spread_ffts_output_[(spread_ffts_output_.position() + other_offset) %
+                                            spread_ffts_output_.size()][bin_position - 1]);
+                }
+
+                if (fft_minus_46[bin_position] > max_neighbor_in_other_adjacent_ffts)
+                {
+                    auto fft_number = spread_ffts_output_.num_written() - 46;
+                    auto peak_magnitude =
+                        std::log(std::max(1.0l / 64, fft_minus_46[bin_position])) * 1477.3 + 6144;
+                    auto peak_magnitude_before =
+                        std::log(std::max(1.0l / 64, fft_minus_46[bin_position - 1])) * 1477.3 +
+                        6144;
+                    auto peak_magnitude_after =
+                        std::log(std::max(1.0l / 64, fft_minus_46[bin_position + 1])) * 1477.3 +
+                        6144;
+
+                    auto peak_variation_1 =
+                        peak_magnitude * 2 - peak_magnitude_before - peak_magnitude_after;
+                    auto peak_variation_2 =
+                        (peak_magnitude_after - peak_magnitude_before) * 32 / peak_variation_1;
+
+                    auto corrected_peak_frequency_bin = bin_position * 64.0 + peak_variation_2;
+                    auto frequency_hz =
+                        corrected_peak_frequency_bin * (16000.0l / 2. / 1024. / 64.);
+
+                    auto band = FrequencyBand();
+                    if (frequency_hz < 250)
+                        continue;
+                    else if (frequency_hz < 520)
+                        band = FrequencyBand::_250_520;
+                    else if (frequency_hz < 1450)
+                        band = FrequencyBand::_520_1450;
+                    else if (frequency_hz < 3500)
+                        band = FrequencyBand::_1450_3500;
+                    else if (frequency_hz <= 5500)
+                        band = FrequencyBand::_3500_5500;
+                    else
+                        continue;
+
+                    auto &band_to_sound_peaks = next_signature_.frequency_band_to_peaks();
+                    if (band_to_sound_peaks.find(band) == band_to_sound_peaks.end())
+                    {
+                        band_to_sound_peaks[band] = std::list<FrequencyPeak>();
+                    }
+
+                    band_to_sound_peaks[band].push_back(
+                        FrequencyPeak(fft_number, static_cast<std::int32_t>(peak_magnitude),
+                                      static_cast<std::int32_t>(corrected_peak_frequency_bin),
+                                      LOW_QUALITY_SAMPLE_RATE));
+                }
+            }
+        }
+    }
+}
+
+void SignatureGenerator::resetSignatureGenerater()
+{
+    next_signature_ = Signature(16000, 0);
+    samples_ring_buffer_ = RingBuffer<std::int16_t>(FFT_BUFFER_CHUNK_SIZE, 0);
+    fft_outputs_ = RingBuffer<decltype(fft_object_)::FFTOutput>(256, {0.0});
+    spread_ffts_output_ = RingBuffer<decltype(fft_object_)::FFTOutput>(256, {0.0});
+}
diff --git a/app/src/main/cpp/vibrafp/lib/algorithm/signature_generator.h b/app/src/main/cpp/vibrafp/lib/algorithm/signature_generator.h
new file mode 100644
index 0000000000..81b6c4ffef
--- /dev/null
+++ b/app/src/main/cpp/vibrafp/lib/algorithm/signature_generator.h
@@ -0,0 +1,49 @@
+#ifndef LIB_ALGORITHM_SIGNATURE_GENERATOR_H_
+#define LIB_ALGORITHM_SIGNATURE_GENERATOR_H_
+
+#include "algorithm/signature.h"
+#include "audio/downsampler.h"
+#include "utils/fft.h"
+#include "utils/ring_buffer.h"
+
+constexpr std::size_t MAX_PEAKS = 255u;
+constexpr std::size_t FFT_BUFFER_CHUNK_SIZE = 2048u;
+
+class SignatureGenerator
+{
+public:
+    SignatureGenerator();
+    void FeedInput(const LowQualityTrack &input);
+    Signature GetNextSignature();
+
+    inline void AddSampleProcessed(std::uint32_t sample_processed)
+    {
+        sample_processed_ += sample_processed;
+    }
+
+    inline void set_max_time_seconds(double max_time_seconds)
+    {
+        max_time_seconds_ = max_time_seconds;
+    }
+
+private:
+    void processInput(const LowQualityTrack &input);
+    void doFFT(const LowQualityTrack &input);
+    void doPeakSpreadingAndRecoginzation();
+    void doPeakSpreading();
+    void doPeakRecognition();
+    void resetSignatureGenerater();
+
+private:
+    LowQualityTrack input_pending_processing_;
+    std::uint32_t sample_processed_;
+    double max_time_seconds_;
+
+    fft::FFT<FFT_BUFFER_CHUNK_SIZE> fft_object_;
+    Signature next_signature_;
+    RingBuffer<std::int16_t> samples_ring_buffer_;
+    RingBuffer<decltype(fft_object_)::FFTOutput> fft_outputs_;
+    RingBuffer<decltype(fft_object_)::FFTOutput> spread_ffts_output_;
+};
+
+#endif // LIB_ALGORITHM_SIGNATURE_GENERATOR_H_
diff --git a/app/src/main/cpp/vibrafp/lib/audio/byte_control.h b/app/src/main/cpp/vibrafp/lib/audio/byte_control.h
new file mode 100644
index 0000000000..1f95079df0
--- /dev/null
+++ b/app/src/main/cpp/vibrafp/lib/audio/byte_control.h
@@ -0,0 +1,29 @@
+#ifndef LIB_AUDIO_BYTE_CONTROL_H_
+#define LIB_AUDIO_BYTE_CONTROL_H_
+
+#include <cstdint>
+
+#define GETINTX(T, cp, i) (*(T *)((unsigned char *)(cp) + (i))) // NOLINT [readability-casting]
+#define GETINT8(cp, i) GETINTX(std::int8_t, (cp), (i))
+#define GETINT16(cp, i) GETINTX(std::int16_t, (cp), (i))
+#define GETINT32(cp, i) GETINTX(std::int32_t, (cp), (i))
+#define GETINT64(cp, i) GETINTX(std::int64_t, (cp), (i))
+
+#ifdef WORDS_BIGENDIAN
+#define GETINT24(cp, i)                                                                            \
+    (((unsigned char *)(cp) + (i))[2] + (((unsigned char *)(cp) + (i))[1] * (1 << 8)) +            \
+     (((signed char *)(cp) + (i))[0] * (1 << 16)))
+#else
+#define GETINT24(cp, i)                                                                            \
+    (((unsigned char *)(cp) + (i))[0] + (((unsigned char *)(cp) + (i))[1] * (1 << 8)) +            \
+     (((signed char *)(cp) + (i))[2] * (1 << 16)))
+#endif
+
+#define GETSAMPLE64(size, cp, i)                                                                   \
+    (((size) == 1)   ? (std::int64_t)GETINT8((cp), (i)) * (1LL << 56)                              \
+     : ((size) == 2) ? (std::int64_t)GETINT16((cp), (i)) * (1LL << 48)                             \
+     : ((size) == 3) ? (std::int64_t)GETINT24((cp), (i)) * (1LL << 40)                             \
+     : ((size) == 4) ? (std::int64_t)GETINT32((cp), (i)) * (1LL << 32)                             \
+                     : (std::int64_t)GETINT64((cp), (i)))
+
+#endif // LIB_AUDIO_BYTE_CONTROL_H_
diff --git a/app/src/main/cpp/vibrafp/lib/audio/downsampler.cpp b/app/src/main/cpp/vibrafp/lib/audio/downsampler.cpp
new file mode 100644
index 0000000000..dbaa5319fb
--- /dev/null
+++ b/app/src/main/cpp/vibrafp/lib/audio/downsampler.cpp
@@ -0,0 +1,179 @@
+#include "audio/downsampler.h"
+#include <cstring>
+#include <algorithm>
+#include <map>
+#include <tuple>
+#include "audio/byte_control.h"
+#include "audio/wav.h"
+
+LowQualityTrack Downsampler::GetLowQualityPCM(const Wav &wav, std::int32_t start_sec,
+                                              std::int32_t end_sec)
+{
+    LowQualityTrack low_quality_pcm;
+
+    const auto channels = wav.num_channels();
+    const auto sample_rate = wav.sample_rate_();
+    const auto bits_per_sample = wav.bits_per_sample();
+    const auto data_size = wav.data_size();
+    const auto audio_format = wav.audio_format();
+    const std::uint8_t *pcm_data = wav.data().get();
+
+    if (channels == 1 && sample_rate == LOW_QUALITY_SAMPLE_RATE &&
+        bits_per_sample == LOW_QUALITY_SAMPLE_BIT_WIDTH && start_sec == 0 && end_sec == -1)
+    {
+        // no need to convert low quality pcm. just copy raw data
+        low_quality_pcm.resize(data_size);
+        std::memcpy(low_quality_pcm.data(), wav.data().get(), data_size);
+        return low_quality_pcm;
+    }
+
+    double downsample_ratio = sample_rate / static_cast<double>(LOW_QUALITY_SAMPLE_RATE);
+    std::uint32_t width = bits_per_sample / 8;
+    std::uint32_t sample_count = data_size / width;
+
+    const void *src_raw_data = pcm_data + (start_sec * sample_rate * width * channels);
+
+    std::uint32_t new_sample_count = sample_count / channels / downsample_ratio;
+
+    if (end_sec != -1)
+    {
+        new_sample_count = (end_sec - start_sec) * LOW_QUALITY_SAMPLE_RATE;
+    }
+
+    low_quality_pcm.resize(new_sample_count);
+
+    auto downsample_func = &Downsampler::signedMonoToMono;
+    bool is_signed = audio_format == 1;
+
+    downsample_func = getDownsampleFunc(is_signed, bits_per_sample, channels);
+    downsample_func(&low_quality_pcm, src_raw_data, downsample_ratio, new_sample_count, width,
+                    channels);
+    return low_quality_pcm;
+}
+
+DownsampleFunc Downsampler::getDownsampleFunc(bool is_signed, std::uint32_t width,
+                                              std::uint32_t channels)
+{
+    channels = std::min(channels, 3u);
+    width = is_signed ? 0 : width;
+
+    static std::map<std::tuple<bool, std::uint32_t, std::uint32_t>, DownsampleFunc> func_map{
+        {std::make_tuple(true, 0, 1), &Downsampler::signedMonoToMono},
+        {std::make_tuple(true, 0, 2), &Downsampler::signedStereoToMono},
+        {std::make_tuple(true, 0, 3), &Downsampler::signedMultiToMono},
+        {std::make_tuple(false, 32, 1), &Downsampler::floatMonoToMono<float>},
+        {std::make_tuple(false, 32, 2), &Downsampler::floatStereoToMono<float>},
+        {std::make_tuple(false, 32, 3), &Downsampler::floatMultiToMono<float>},
+        {std::make_tuple(false, 64, 1), &Downsampler::floatMonoToMono<double>},
+        {std::make_tuple(false, 64, 2), &Downsampler::floatStereoToMono<double>},
+        {std::make_tuple(false, 64, 3), &Downsampler::floatMultiToMono<double>},
+    };
+    return func_map.at(std::make_tuple(is_signed, width, channels));
+}
+
+void Downsampler::signedMonoToMono(LowQualityTrack *dst, const void *src, double downsample_ratio,
+                                   std::uint32_t new_sample_count, std::uint32_t width,
+                                   std::uint32_t channels)
+{
+    std::uint32_t index = 0;
+    for (std::uint32_t i = 0; i < new_sample_count; i++)
+    {
+        index = std::uint32_t(i * downsample_ratio) * width * channels;
+        dst->at(i) = GETSAMPLE64(width, src, index) >> (64 - LOW_QUALITY_SAMPLE_BIT_WIDTH);
+    }
+}
+
+void Downsampler::signedStereoToMono(LowQualityTrack *dst, const void *src, double downsample_ratio,
+                                     std::uint32_t new_sample_count, std::uint32_t width,
+                                     std::uint32_t channels)
+{
+    std::uint32_t index = 0;
+    for (std::uint32_t i = 0; i < new_sample_count; i++)
+    {
+        index = std::uint32_t(i * downsample_ratio) * width * channels;
+        LowQualitySample sample1 =
+            GETSAMPLE64(width, src, index) >> (64 - LOW_QUALITY_SAMPLE_BIT_WIDTH);
+        LowQualitySample sample2 =
+            GETSAMPLE64(width, src, index + width) >> (64 - LOW_QUALITY_SAMPLE_BIT_WIDTH);
+        dst->at(i) = (sample1 + sample2) / 2;
+    }
+}
+
+void Downsampler::signedMultiToMono(LowQualityTrack *dst, const void *src, double downsample_ratio,
+                                    std::uint32_t new_sample_count, std::uint32_t width,
+                                    std::uint32_t channels)
+{
+    double collected_sample = 0;
+    std::uint32_t index = 0;
+    for (std::uint32_t i = 0; i < new_sample_count; i++)
+    {
+        collected_sample = 0;
+        for (std::uint32_t k = 0; k < channels; k++)
+        {
+            index = std::uint32_t(i * downsample_ratio) * width * channels;
+            collected_sample +=
+                GETSAMPLE64(width, src, index + k * width) >> (64 - LOW_QUALITY_SAMPLE_BIT_WIDTH);
+        }
+        dst->at(i) = LowQualitySample(collected_sample / channels);
+    }
+}
+
+template <typename T>
+void Downsampler::floatMonoToMono(LowQualityTrack *dst, const void *src, double downsample_ratio,
+                                  std::uint32_t new_sample_count, std::uint32_t width,
+                                  std::uint32_t channels)
+{
+    T temp_float_sample = 0;
+    std::uint64_t temp_sample = 0;
+    std::uint32_t index = 0;
+    for (std::uint32_t i = 0; i < new_sample_count; i++)
+    {
+        index = std::uint32_t(i * downsample_ratio) * width * channels;
+        temp_sample = GETSAMPLE64(width, src, index) >> (64 - sizeof(T) * 8);
+        temp_float_sample = *reinterpret_cast<T *>(&temp_sample);
+        dst->at(i) = LowQualitySample(temp_float_sample * LOW_QUALITY_SAMPLE_MAX);
+    }
+}
+
+template <typename T>
+void Downsampler::floatStereoToMono(LowQualityTrack *dst, const void *src, double downsample_ratio,
+                                    std::uint32_t new_sample_count, std::uint32_t width,
+                                    std::uint32_t channels)
+{
+    std::uint64_t temp_sample1 = 0;
+    std::uint64_t temp_sample2 = 0;
+    T temp_float_sample1 = 0;
+    T temp_float_sample2 = 0;
+    std::uint32_t index = 0;
+    for (std::uint32_t i = 0; i < new_sample_count; i++)
+    {
+        index = std::uint32_t(i * downsample_ratio) * width * channels;
+        temp_sample1 = GETSAMPLE64(width, src, index) >> (64 - sizeof(T) * 8);
+        temp_sample2 = GETSAMPLE64(width, src, index + width) >> (64 - sizeof(T) * 8);
+        temp_float_sample1 = *reinterpret_cast<T *>(&temp_sample1);
+        temp_float_sample2 = *reinterpret_cast<T *>(&temp_sample2);
+        dst->at(i) = LowQualitySample((temp_float_sample1 + temp_float_sample2) / 2 *
+                                      LOW_QUALITY_SAMPLE_MAX);
+    }
+}
+
+template <typename T>
+void Downsampler::floatMultiToMono(LowQualityTrack *dst, const void *src, double downsample_ratio,
+                                   std::uint32_t new_sample_count, std::uint32_t width,
+                                   std::uint32_t channels)
+{
+    std::uint32_t index = 0;
+    T collected_sample = 0;
+    std::uint64_t temp_sample = 0;
+    for (std::uint32_t i = 0; i < new_sample_count; i++)
+    {
+        collected_sample = 0;
+        index = std::uint32_t(i * downsample_ratio) * width * channels;
+        for (std::uint32_t k = 0; k < channels; k++)
+        {
+            temp_sample = GETSAMPLE64(width, src, index + k * width) >> (64 - sizeof(T) * 8);
+            collected_sample += *reinterpret_cast<T *>(&temp_sample);
+        }
+        dst->at(i) = LowQualitySample(collected_sample / channels * LOW_QUALITY_SAMPLE_MAX);
+    }
+}
diff --git a/app/src/main/cpp/vibrafp/lib/audio/downsampler.h b/app/src/main/cpp/vibrafp/lib/audio/downsampler.h
new file mode 100644
index 0000000000..d38b138062
--- /dev/null
+++ b/app/src/main/cpp/vibrafp/lib/audio/downsampler.h
@@ -0,0 +1,55 @@
+#ifndef LIB_AUDIO_DOWNSAMPLER_H_
+#define LIB_AUDIO_DOWNSAMPLER_H_
+
+#include <cstdint>
+#include <vector>
+
+// forward declaration
+class Wav;
+//
+
+using LowQualitySample = std::int16_t;
+using LowQualityTrack = std::vector<LowQualitySample>;
+
+constexpr std::uint32_t LOW_QUALITY_SAMPLE_RATE = 16000;
+constexpr std::uint32_t LOW_QUALITY_SAMPLE_BIT_WIDTH = sizeof(LowQualitySample) * 8;
+constexpr std::uint32_t LOW_QUALITY_SAMPLE_MAX = 32767;
+
+using DownsampleFunc = void (*)(LowQualityTrack *, const void *, double, std::uint32_t,
+                                std::uint32_t, std::uint32_t);
+
+class Downsampler
+{
+public:
+    static LowQualityTrack GetLowQualityPCM(const Wav &wav, std::int32_t start_sec = 0,
+                                            std::int32_t end_sec = -1);
+
+private:
+    static DownsampleFunc getDownsampleFunc(bool is_signed, std::uint32_t width,
+                                            std::uint32_t channels);
+
+    static void signedStereoToMono(LowQualityTrack *dst, const void *src, double downsample_ratio,
+                                   std::uint32_t new_sample_count, std::uint32_t width,
+                                   std::uint32_t channels);
+    static void signedMonoToMono(LowQualityTrack *dst, const void *src, double downsample_ratio,
+                                 std::uint32_t new_sample_count, std::uint32_t width,
+                                 std::uint32_t channels);
+    static void signedMultiToMono(LowQualityTrack *dst, const void *src, double downsample_ratio,
+                                  std::uint32_t new_sample_count, std::uint32_t width,
+                                  std::uint32_t channels);
+
+    template <typename T>
+    static void floatStereoToMono(LowQualityTrack *dst, const void *src, double downsample_ratio,
+                                  std::uint32_t new_sample_count, std::uint32_t width,
+                                  std::uint32_t channels);
+    template <typename T>
+    static void floatMonoToMono(LowQualityTrack *dst, const void *src, double downsample_ratio,
+                                std::uint32_t new_sample_count, std::uint32_t width,
+                                std::uint32_t channels);
+    template <typename T>
+    static void floatMultiToMono(LowQualityTrack *dst, const void *src, double downsample_ratio,
+                                 std::uint32_t new_sample_count, std::uint32_t width,
+                                 std::uint32_t channels);
+};
+
+#endif // LIB_AUDIO_DOWNSAMPLER_H_
diff --git a/app/src/main/cpp/vibrafp/lib/audio/wav.cpp b/app/src/main/cpp/vibrafp/lib/audio/wav.cpp
new file mode 100644
index 0000000000..f4dbaddb74
--- /dev/null
+++ b/app/src/main/cpp/vibrafp/lib/audio/wav.cpp
@@ -0,0 +1,109 @@
+#include "audio/wav.h"
+#include <cassert>
+#include <cmath>
+#include <cstring>
+#include <fstream>
+#include <iostream>
+#include <sstream>
+#include <string>
+
+Wav Wav::FromFile(const std::string &wav_file_path)
+{
+    Wav wav;
+    wav.wav_file_path_ = wav_file_path;
+    std::ifstream stream(wav_file_path, std::ios::binary);
+    if (!stream.is_open())
+    {
+        throw std::runtime_error("Failed to open WAV file");
+    }
+    wav.readWavFileBuffer(stream);
+    return wav;
+}
+
+Wav Wav::FromRawWav(const char *raw_wav, std::uint32_t raw_wav_size)
+{
+    Wav wav;
+    std::istringstream stream(std::string(raw_wav, raw_wav_size));
+    wav.readWavFileBuffer(stream);
+    return wav;
+}
+
+Wav Wav::FromSignedPCM(const char *raw_pcm, std::uint32_t raw_pcm_size, std::uint32_t sample_rate,
+                       std::uint32_t sample_width, std::uint32_t channel_count)
+{
+    return fromPCM(raw_pcm, raw_pcm_size, AudioFormat::PCM_INTEGER, sample_rate, sample_width,
+                   channel_count);
+}
+
+Wav Wav::FromFloatPCM(const char *raw_pcm, std::uint32_t raw_pcm_size, std::uint32_t sample_rate,
+                      std::uint32_t sample_width, std::uint32_t channel_count)
+{
+    return fromPCM(raw_pcm, raw_pcm_size, AudioFormat::PCM_FLOAT, sample_rate, sample_width,
+                   channel_count);
+}
+
+Wav::~Wav()
+{
+}
+
+Wav Wav::fromPCM(const char *raw_pcm, std::uint32_t raw_pcm_size, AudioFormat audio_format,
+                 std::uint32_t sample_rate, std::uint32_t sample_width, std::uint32_t channel_count)
+{
+    Wav wav;
+    wav.header_.file_size = sizeof(WavHeader) + sizeof(FmtSubchunk) + 8 + raw_pcm_size;
+    wav.fmt_.audio_format = static_cast<std::uint16_t>(audio_format);
+    wav.fmt_.num_channels = channel_count;
+    wav.fmt_.sample_rate = sample_rate;
+    wav.fmt_.byte_rate = sample_rate * channel_count * sample_width / 8;
+    wav.fmt_.block_align = channel_count * sample_width / 8;
+    wav.fmt_.bits_per_sample = sample_width;
+    wav.data_size_ = raw_pcm_size;
+    wav.data_.reset(new std::uint8_t[raw_pcm_size]);
+    std::memcpy(wav.data_.get(), raw_pcm, raw_pcm_size);
+    return wav;
+}
+
+void Wav::readWavFileBuffer(std::istream &stream)
+{
+    stream.read(reinterpret_cast<char *>(&header_), sizeof(WavHeader));
+
+    const auto kSubchunkLimit = 10;
+
+    bool data_chunk_found = false;
+    bool fmt_chunk_found = false;
+    for (int i = 0; i < kSubchunkLimit && stream.tellg() < header_.file_size - 8; i++)
+    {
+        char subchunk_id[4];
+        stream.read(subchunk_id, 4);
+
+        std::uint32_t subchunk_size;
+        stream.read(reinterpret_cast<char *>(&subchunk_size), 4);
+
+        if (strncmp(subchunk_id, "data", 4) == 0)
+        {
+            data_size_ = subchunk_size;
+            data_.reset(new std::uint8_t[data_size_]);
+            stream.read(reinterpret_cast<char *>(data_.get()), data_size_);
+            data_chunk_found = true;
+        }
+        else if (strncmp(subchunk_id, "fmt ", 4) == 0)
+        {
+            stream.read(reinterpret_cast<char *>(&fmt_), sizeof(FmtSubchunk));
+            fmt_chunk_found = true;
+        }
+        else
+        {
+            stream.seekg(subchunk_size, std::ios::cur);
+        }
+
+        if (data_chunk_found && fmt_chunk_found)
+        {
+            return; // read wav successfully
+        }
+    }
+
+    if (!data_chunk_found || !fmt_chunk_found)
+    {
+        throw std::runtime_error("Invalid WAV file");
+    }
+}
diff --git a/app/src/main/cpp/vibrafp/lib/audio/wav.h b/app/src/main/cpp/vibrafp/lib/audio/wav.h
new file mode 100644
index 0000000000..079526b34d
--- /dev/null
+++ b/app/src/main/cpp/vibrafp/lib/audio/wav.h
@@ -0,0 +1,90 @@
+#ifndef LIB_AUDIO_WAV_H_
+#define LIB_AUDIO_WAV_H_
+
+#include <memory>
+#include <string>
+#include "audio/byte_control.h"
+
+struct WavHeader
+{
+    char riff_header[4]; // "RIFF"
+    std::uint32_t file_size;
+    char wave_header[4]; // "WAVE"
+};
+
+struct FmtSubchunk
+{
+    std::uint16_t audio_format; // 1 = PCM, 3 = IEEE float, etc.
+    std::uint16_t num_channels;
+    std::uint32_t sample_rate;
+    std::uint32_t byte_rate;
+    std::uint16_t block_align;
+    std::uint16_t bits_per_sample;
+};
+
+enum class AudioFormat
+{
+    PCM_INTEGER = 1,
+    PCM_FLOAT = 3,
+};
+
+class Wav
+{
+public:
+    Wav(Wav &&) = default;
+    Wav(const Wav &) = delete;
+    static Wav FromFile(const std::string &wav_file_path);
+    static Wav FromRawWav(const char *raw_wav, std::uint32_t raw_wav_size);
+    static Wav FromSignedPCM(const char *raw_pcm, std::uint32_t raw_pcm_size,
+                             std::uint32_t sample_rate, std::uint32_t sample_width,
+                             std::uint32_t channel_count);
+    static Wav FromFloatPCM(const char *raw_pcm, std::uint32_t raw_pcm_size,
+                            std::uint32_t sample_rate, std::uint32_t sample_width,
+                            std::uint32_t channel_count);
+    ~Wav();
+
+    inline std::uint16_t audio_format() const
+    {
+        return fmt_.audio_format;
+    }
+    inline std::uint16_t num_channels() const
+    {
+        return fmt_.num_channels;
+    }
+    inline std::uint32_t sample_rate_() const
+    {
+        return fmt_.sample_rate;
+    }
+    inline std::uint32_t bits_per_sample() const
+    {
+        return fmt_.bits_per_sample;
+    }
+    inline std::uint32_t data_size() const
+    {
+        return data_size_;
+    }
+    inline std::uint32_t file_size() const
+    {
+        return header_.file_size;
+    }
+    inline const std::unique_ptr<std::uint8_t[]> &data() const
+    {
+        return data_;
+    }
+
+private:
+    Wav() = default;
+    static Wav fromPCM(const char *raw_pcm, std::uint32_t raw_pcm_size, AudioFormat audio_format,
+                       std::uint32_t sample_rate, std::uint32_t sample_width,
+                       std::uint32_t channel_count);
+    void readWavFileBuffer(std::istream &stream);
+
+private:
+    WavHeader header_;
+    FmtSubchunk fmt_;
+    std::string wav_file_path_;
+    std::uint32_t data_size_;
+    std::unique_ptr<std::uint8_t[]> data_;
+};
+
+#endif // LIB_AUDIO_WAV_H_
diff --git a/app/src/main/cpp/vibrafp/lib/utils/base64.h b/app/src/main/cpp/vibrafp/lib/utils/base64.h
new file mode 100644
index 0000000000..f27c1a2dc7
--- /dev/null
+++ b/app/src/main/cpp/vibrafp/lib/utils/base64.h
@@ -0,0 +1,55 @@
+#ifndef LIB_UTILS_BASE64_H_
+#define LIB_UTILS_BASE64_H_
+
+#include <string>
+
+namespace base64
+{
+static const char base64_chars[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
+                                   "abcdefghijklmnopqrstuvwxyz"
+                                   "0123456789+/";
+std::string encode(const char *bytes_to_encode, unsigned int in_len)
+{
+    std::string ret;
+    int i = 0;
+    int j = 0;
+    unsigned char char_array_3[3];
+    unsigned char char_array_4[4];
+
+    while (in_len--)
+    {
+        char_array_3[i++] = *(bytes_to_encode++);
+        if (i == 3)
+        {
+            char_array_4[0] = (char_array_3[0] & 0xfc) >> 2;
+            char_array_4[1] = ((char_array_3[0] & 0x03) << 4) + ((char_array_3[1] & 0xf0) >> 4);
+            char_array_4[2] = ((char_array_3[1] & 0x0f) << 2) + ((char_array_3[2] & 0xc0) >> 6);
+            char_array_4[3] = char_array_3[2] & 0x3f;
+
+            for (i = 0; (i < 4); i++)
+                ret += base64_chars[char_array_4[i]];
+            i = 0;
+        }
+    }
+
+    if (i)
+    {
+        for (j = i; j < 3; j++)
+            char_array_3[j] = '\0';
+
+        char_array_4[0] = (char_array_3[0] & 0xfc) >> 2;
+        char_array_4[1] = ((char_array_3[0] & 0x03) << 4) + ((char_array_3[1] & 0xf0) >> 4);
+        char_array_4[2] = ((char_array_3[1] & 0x0f) << 2) + ((char_array_3[2] & 0xc0) >> 6);
+
+        for (j = 0; (j < i + 1); j++)
+            ret += base64_chars[char_array_4[j]];
+
+        while ((i++ < 3))
+            ret += '=';
+    }
+
+    return ret;
+}
+} // namespace base64
+
+#endif // LIB_UTILS_BASE64_H_
diff --git a/app/src/main/cpp/vibrafp/lib/utils/crc32.h b/app/src/main/cpp/vibrafp/lib/utils/crc32.h
new file mode 100644
index 0000000000..1f38fe5871
--- /dev/null
+++ b/app/src/main/cpp/vibrafp/lib/utils/crc32.h
@@ -0,0 +1,28 @@
+#ifndef LIB_UTILS_CRC32_H_
+#define LIB_UTILS_CRC32_H_
+
+namespace crc32
+{
+std::uint32_t crc32(const char *buf, std::size_t len)
+{
+    std::uint32_t crc_table[256];
+    std::uint32_t crc;
+    std::size_t i, j;
+
+    for (i = 0; i < 256; i++)
+    {
+        crc = i;
+        for (j = 0; j < 8; j++)
+            crc = crc & 1 ? (crc >> 1) ^ 0xEDB88320UL : crc >> 1;
+        crc_table[i] = crc;
+    };
+    crc = 0xFFFFFFFFUL;
+
+    while (len--)
+        crc = crc_table[(crc ^ *buf++) & 0xFF] ^ (crc >> 8);
+
+    return crc ^ 0xFFFFFFFFUL;
+}
+} // namespace crc32
+
+#endif // LIB_UTILS_CRC32_H_
diff --git a/app/src/main/cpp/vibrafp/lib/utils/fft.h b/app/src/main/cpp/vibrafp/lib/utils/fft.h
new file mode 100644
index 0000000000..ad2b7c671e
--- /dev/null
+++ b/app/src/main/cpp/vibrafp/lib/utils/fft.h
@@ -0,0 +1,78 @@
+#ifndef LIB_UTILS_FFT_H_
+#define LIB_UTILS_FFT_H_
+
+#include <cmath>
+#include <algorithm>
+#include <cassert>
+#include <fftw3.h> // NOLINT [include_order]
+#include <memory>
+#include <vector>
+
+namespace fft
+{
+
+template <int INPUT_SIZE>
+class FFT
+{
+public:
+    constexpr static const int OUTPUT_SIZE = INPUT_SIZE / 2 + 1;
+    using FFTOutput = std::array<long double, OUTPUT_SIZE>;
+
+public:
+    FFT()
+        : input_data_buffer_(fftw_alloc_real(INPUT_SIZE), fftw_free),
+          output_data_buffer_(fftw_alloc_complex(OUTPUT_SIZE), fftw_free)
+    {
+        fftw_plan_ = fftw_plan_dft_r2c_1d(INPUT_SIZE, input_data_buffer_.get(),
+                                          output_data_buffer_.get(), FFTW_ESTIMATE);
+    }
+    FFT(const FFT &) = delete;
+    FFT &operator=(const FFT &) = delete;
+    FFT(FFT &&) = delete;
+    FFT &operator=(FFT &&) = delete;
+
+    template <typename Iterable> FFTOutput RFFT(const Iterable &input)
+    {
+        assert(input.size() == INPUT_SIZE &&
+               "Input size must be equal to the input size specified in the constructor");
+
+        FFTOutput real_output;
+
+        // Copy and convert the input data to double
+        for (std::size_t i = 0; i < INPUT_SIZE; i++)
+        {
+            input_data_buffer_.get()[i] = static_cast<double>(input[i]);
+        }
+        fftw_execute(fftw_plan_);
+
+        double real_val = 0.0;
+        double imag_val = 0.0;
+        const double min_val = 1e-10;
+        const double scale_factor = 1.0 / (1 << 17);
+
+        // do max((real^2 + imag^2) / (1 << 17), 0.0000000001)
+        for (std::size_t i = 0; i < OUTPUT_SIZE; ++i)
+        {
+            real_val = output_data_buffer_.get()[i][0];
+            imag_val = output_data_buffer_.get()[i][1];
+
+            real_val = (real_val * real_val + imag_val * imag_val) * scale_factor;
+            real_output[i] = (real_val < min_val) ? min_val : real_val;
+        }
+        return real_output;
+    }
+
+    virtual ~FFT()
+    {
+        fftw_destroy_plan(fftw_plan_);
+        fftw_cleanup();
+    }
+
+private:
+    fftw_plan fftw_plan_;
+    std::unique_ptr<double, decltype(&fftw_free)> input_data_buffer_;
+    std::unique_ptr<fftw_complex, decltype(&fftw_free)> output_data_buffer_;
+};
+} // namespace fft
+
+#endif // LIB_UTILS_FFT_H_
diff --git a/app/src/main/cpp/vibrafp/lib/utils/hanning.h b/app/src/main/cpp/vibrafp/lib/utils/hanning.h
new file mode 100644
index 0000000000..96a92a3c13
--- /dev/null
+++ b/app/src/main/cpp/vibrafp/lib/utils/hanning.h
@@ -0,0 +1,348 @@
+#ifndef LIB_UTILS_HANNING_H_
+#define LIB_UTILS_HANNING_H_
+
+constexpr double HANNIG_MATRIX[] = {
+    0.0000023508, 0.0000094032, 0.0000211571, 0.0000376123, 0.0000587689, 0.0000846264,
+    0.0001151848, 0.0001504437, 0.0001904028, 0.0002350617, 0.0002844199, 0.0003384771,
+    0.0003972327, 0.0004606862, 0.0005288369, 0.0006016843, 0.0006792276, 0.0007614661,
+    0.0008483991, 0.0009400256, 0.0010363449, 0.0011373561, 0.0012430582, 0.0013534502,
+    0.0014685311, 0.0015882997, 0.0017127550, 0.0018418958, 0.0019757209, 0.0021142290,
+    0.0022574189, 0.0024052891, 0.0025578382, 0.0027150650, 0.0028769677, 0.0030435451,
+    0.0032147954, 0.0033907171, 0.0035713085, 0.0037565679, 0.0039464936, 0.0041410837,
+    0.0043403366, 0.0045442502, 0.0047528227, 0.0049660521, 0.0051839364, 0.0054064735,
+    0.0056336614, 0.0058654980, 0.0061019809, 0.0063431081, 0.0065888773, 0.0068392860,
+    0.0070943321, 0.0073540131, 0.0076183265, 0.0078872699, 0.0081608407, 0.0084390363,
+    0.0087218542, 0.0090092917, 0.0093013461, 0.0095980146, 0.0098992944, 0.0102051828,
+    0.0105156768, 0.0108307735, 0.0111504700, 0.0114747632, 0.0118036501, 0.0121371277,
+    0.0124751927, 0.0128178420, 0.0131650723, 0.0135168805, 0.0138732631, 0.0142342169,
+    0.0145997385, 0.0149698243, 0.0153444710, 0.0157236751, 0.0161074328, 0.0164957407,
+    0.0168885951, 0.0172859922, 0.0176879285, 0.0180944000, 0.0185054029, 0.0189209335,
+    0.0193409877, 0.0197655616, 0.0201946513, 0.0206282527, 0.0210663617, 0.0215089742,
+    0.0219560861, 0.0224076931, 0.0228637910, 0.0233243755, 0.0237894423, 0.0242589870,
+    0.0247330052, 0.0252114924, 0.0256944441, 0.0261818558, 0.0266737229, 0.0271700408,
+    0.0276708049, 0.0281760103, 0.0286856523, 0.0291997263, 0.0297182272, 0.0302411503,
+    0.0307684907, 0.0313002433, 0.0318364032, 0.0323769653, 0.0329219246, 0.0334712759,
+    0.0340250141, 0.0345831339, 0.0351456301, 0.0357124975, 0.0362837306, 0.0368593242,
+    0.0374392727, 0.0380235708, 0.0386122130, 0.0392051936, 0.0398025073, 0.0404041482,
+    0.0410101108, 0.0416203894, 0.0422349782, 0.0428538715, 0.0434770634, 0.0441045481,
+    0.0447363196, 0.0453723721, 0.0460126996, 0.0466572959, 0.0473061552, 0.0479592712,
+    0.0486166378, 0.0492782489, 0.0499440982, 0.0506141795, 0.0512884865, 0.0519670127,
+    0.0526497519, 0.0533366976, 0.0540278434, 0.0547231828, 0.0554227092, 0.0561264160,
+    0.0568342966, 0.0575463445, 0.0582625528, 0.0589829148, 0.0597074238, 0.0604360730,
+    0.0611688555, 0.0619057644, 0.0626467928, 0.0633919337, 0.0641411801, 0.0648945250,
+    0.0656519612, 0.0664134817, 0.0671790793, 0.0679487469, 0.0687224770, 0.0695002626,
+    0.0702820963, 0.0710679706, 0.0718578783, 0.0726518119, 0.0734497639, 0.0742517269,
+    0.0750576933, 0.0758676555, 0.0766816058, 0.0774995368, 0.0783214406, 0.0791473095,
+    0.0799771357, 0.0808109116, 0.0816486291, 0.0824902805, 0.0833358578, 0.0841853531,
+    0.0850387583, 0.0858960656, 0.0867572667, 0.0876223536, 0.0884913182, 0.0893641523,
+    0.0902408477, 0.0911213962, 0.0920057894, 0.0928940190, 0.0937860768, 0.0946819542,
+    0.0955816430, 0.0964851345, 0.0973924204, 0.0983034921, 0.0992183410, 0.1001369586,
+    0.1010593361, 0.1019854650, 0.1029153364, 0.1038489418, 0.1047862722, 0.1057273189,
+    0.1066720730, 0.1076205257, 0.1085726679, 0.1095284909, 0.1104879855, 0.1114511428,
+    0.1124179537, 0.1133884090, 0.1143624998, 0.1153402168, 0.1163215508, 0.1173064927,
+    0.1182950331, 0.1192871627, 0.1202828722, 0.1212821523, 0.1222849936, 0.1232913866,
+    0.1243013218, 0.1253147898, 0.1263317811, 0.1273522860, 0.1283762950, 0.1294037985,
+    0.1304347867, 0.1314692500, 0.1325071788, 0.1335485631, 0.1345933932, 0.1356416593,
+    0.1366933516, 0.1377484601, 0.1388069749, 0.1398688861, 0.1409341836, 0.1420028576,
+    0.1430748978, 0.1441502943, 0.1452290369, 0.1463111155, 0.1473965199, 0.1484852399,
+    0.1495772653, 0.1506725857, 0.1517711910, 0.1528730707, 0.1539782145, 0.1550866121,
+    0.1561982529, 0.1573131265, 0.1584312225, 0.1595525304, 0.1606770395, 0.1618047394,
+    0.1629356193, 0.1640696688, 0.1652068770, 0.1663472334, 0.1674907272, 0.1686373477,
+    0.1697870840, 0.1709399254, 0.1720958610, 0.1732548799, 0.1744169713, 0.1755821242,
+    0.1767503277, 0.1779215707, 0.1790958423, 0.1802731315, 0.1814534271, 0.1826367180,
+    0.1838229932, 0.1850122415, 0.1862044516, 0.1873996124, 0.1885977127, 0.1897987412,
+    0.1910026865, 0.1922095374, 0.1934192825, 0.1946319104, 0.1958474098, 0.1970657692,
+    0.1982869772, 0.1995110222, 0.2007378927, 0.2019675773, 0.2032000643, 0.2044353422,
+    0.2056733994, 0.2069142242, 0.2081578049, 0.2094041298, 0.2106531873, 0.2119049656,
+    0.2131594529, 0.2144166374, 0.2156765073, 0.2169390508, 0.2182042559, 0.2194721108,
+    0.2207426036, 0.2220157223, 0.2232914549, 0.2245697895, 0.2258507140, 0.2271342163,
+    0.2284202845, 0.2297089064, 0.2310000699, 0.2322937629, 0.2335899731, 0.2348886885,
+    0.2361898967, 0.2374935856, 0.2387997429, 0.2401083564, 0.2414194136, 0.2427329023,
+    0.2440488102, 0.2453671248, 0.2466878338, 0.2480109247, 0.2493363851, 0.2506642026,
+    0.2519943646, 0.2533268587, 0.2546616722, 0.2559987928, 0.2573382077, 0.2586799044,
+    0.2600238703, 0.2613700928, 0.2627185591, 0.2640692567, 0.2654221727, 0.2667772945,
+    0.2681346094, 0.2694941045, 0.2708557672, 0.2722195845, 0.2735855437, 0.2749536319,
+    0.2763238362, 0.2776961439, 0.2790705418, 0.2804470173, 0.2818255572, 0.2832061487,
+    0.2845887787, 0.2859734343, 0.2873601024, 0.2887487700, 0.2901394241, 0.2915320515,
+    0.2929266392, 0.2943231740, 0.2957216428, 0.2971220325, 0.2985243300, 0.2999285219,
+    0.3013345951, 0.3027425364, 0.3041523326, 0.3055639704, 0.3069774365, 0.3083927176,
+    0.3098098005, 0.3112286717, 0.3126493180, 0.3140717260, 0.3154958823, 0.3169217735,
+    0.3183493863, 0.3197787071, 0.3212097227, 0.3226424194, 0.3240767838, 0.3255128025,
+    0.3269504619, 0.3283897485, 0.3298306489, 0.3312731493, 0.3327172363, 0.3341628964,
+    0.3356101158, 0.3370588810, 0.3385091784, 0.3399609943, 0.3414143150, 0.3428691270,
+    0.3443254166, 0.3457831699, 0.3472423734, 0.3487030133, 0.3501650759, 0.3516285474,
+    0.3530934141, 0.3545596622, 0.3560272778, 0.3574962473, 0.3589665568, 0.3604381924,
+    0.3619111404, 0.3633853868, 0.3648609179, 0.3663377196, 0.3678157783, 0.3692950799,
+    0.3707756105, 0.3722573563, 0.3737403032, 0.3752244374, 0.3767097449, 0.3781962117,
+    0.3796838239, 0.3811725674, 0.3826624282, 0.3841533924, 0.3856454460, 0.3871385748,
+    0.3886327649, 0.3901280022, 0.3916242727, 0.3931215622, 0.3946198567, 0.3961191422,
+    0.3976194044, 0.3991206294, 0.4006228029, 0.4021259109, 0.4036299393, 0.4051348738,
+    0.4066407004, 0.4081474048, 0.4096549729, 0.4111633906, 0.4126726436, 0.4141827178,
+    0.4156935990, 0.4172052728, 0.4187177253, 0.4202309420, 0.4217449088, 0.4232596115,
+    0.4247750358, 0.4262911674, 0.4278079921, 0.4293254957, 0.4308436638, 0.4323624822,
+    0.4338819366, 0.4354020128, 0.4369226964, 0.4384439731, 0.4399658286, 0.4414882486,
+    0.4430112189, 0.4445347250, 0.4460587526, 0.4475832875, 0.4491083153, 0.4506338216,
+    0.4521597921, 0.4536862125, 0.4552130684, 0.4567403454, 0.4582680291, 0.4597961053,
+    0.4613245596, 0.4628533775, 0.4643825447, 0.4659120468, 0.4674418695, 0.4689719983,
+    0.4705024189, 0.4720331168, 0.4735640778, 0.4750952873, 0.4766267310, 0.4781583944,
+    0.4796902633, 0.4812223231, 0.4827545595, 0.4842869581, 0.4858195044, 0.4873521841,
+    0.4888849827, 0.4904178858, 0.4919508790, 0.4934839479, 0.4950170780, 0.4965502551,
+    0.4980834645, 0.4996166920, 0.5011499231, 0.5026831434, 0.5042163384, 0.5057494938,
+    0.5072825951, 0.5088156280, 0.5103485780, 0.5118814306, 0.5134141715, 0.5149467863,
+    0.5164792606, 0.5180115799, 0.5195437298, 0.5210756959, 0.5226074639, 0.5241390193,
+    0.5256703477, 0.5272014347, 0.5287322659, 0.5302628270, 0.5317931035, 0.5333230810,
+    0.5348527452, 0.5363820817, 0.5379110760, 0.5394397139, 0.5409679809, 0.5424958627,
+    0.5440233449, 0.5455504131, 0.5470770530, 0.5486032503, 0.5501289905, 0.5516542593,
+    0.5531790424, 0.5547033255, 0.5562270942, 0.5577503341, 0.5592730311, 0.5607951706,
+    0.5623167385, 0.5638377205, 0.5653581021, 0.5668778692, 0.5683970074, 0.5699155024,
+    0.5714333401, 0.5729505060, 0.5744669860, 0.5759827657, 0.5774978309, 0.5790121675,
+    0.5805257610, 0.5820385974, 0.5835506623, 0.5850619416, 0.5865724210, 0.5880820864,
+    0.5895909235, 0.5910989182, 0.5926060563, 0.5941123235, 0.5956177058, 0.5971221890,
+    0.5986257590, 0.6001284015, 0.6016301025, 0.6031308479, 0.6046306235, 0.6061294153,
+    0.6076272091, 0.6091239908, 0.6106197465, 0.6121144619, 0.6136081231, 0.6151007161,
+    0.6165922267, 0.6180826410, 0.6195719449, 0.6210601245, 0.6225471657, 0.6240330546,
+    0.6255177772, 0.6270013195, 0.6284836676, 0.6299648076, 0.6314447254, 0.6329234073,
+    0.6344008392, 0.6358770074, 0.6373518979, 0.6388254968, 0.6402977903, 0.6417687646,
+    0.6432384058, 0.6447067001, 0.6461736337, 0.6476391928, 0.6491033636, 0.6505661323,
+    0.6520274853, 0.6534874087, 0.6549458889, 0.6564029120, 0.6578584645, 0.6593125326,
+    0.6607651027, 0.6622161610, 0.6636656940, 0.6651136880, 0.6665601294, 0.6680050047,
+    0.6694483001, 0.6708900022, 0.6723300973, 0.6737685721, 0.6752054128, 0.6766406060,
+    0.6780741383, 0.6795059961, 0.6809361660, 0.6823646344, 0.6837913881, 0.6852164136,
+    0.6866396974, 0.6880612262, 0.6894809866, 0.6908989653, 0.6923151490, 0.6937295243,
+    0.6951420779, 0.6965527965, 0.6979616669, 0.6993686758, 0.7007738101, 0.7021770564,
+    0.7035784016, 0.7049778325, 0.7063753360, 0.7077708989, 0.7091645081, 0.7105561504,
+    0.7119458129, 0.7133334824, 0.7147191459, 0.7161027903, 0.7174844027, 0.7188639700,
+    0.7202414793, 0.7216169176, 0.7229902721, 0.7243615297, 0.7257306776, 0.7270977029,
+    0.7284625927, 0.7298253343, 0.7311859148, 0.7325443214, 0.7339005413, 0.7352545618,
+    0.7366063702, 0.7379559537, 0.7393032997, 0.7406483955, 0.7419912284, 0.7433317858,
+    0.7446700551, 0.7460060237, 0.7473396791, 0.7486710087, 0.7500000000, 0.7513266405,
+    0.7526509177, 0.7539728192, 0.7552923326, 0.7566094454, 0.7579241452, 0.7592364197,
+    0.7605462566, 0.7618536435, 0.7631585681, 0.7644610182, 0.7657609816, 0.7670584459,
+    0.7683533990, 0.7696458288, 0.7709357230, 0.7722230696, 0.7735078563, 0.7747900713,
+    0.7760697023, 0.7773467374, 0.7786211646, 0.7798929718, 0.7811621471, 0.7824286786,
+    0.7836925544, 0.7849537626, 0.7862122913, 0.7874681286, 0.7887212629, 0.7899716822,
+    0.7912193749, 0.7924643292, 0.7937065334, 0.7949459759, 0.7961826448, 0.7974165288,
+    0.7986476160, 0.7998758950, 0.8011013543, 0.8023239822, 0.8035437673, 0.8047606981,
+    0.8059747632, 0.8071859511, 0.8083942505, 0.8095996501, 0.8108021384, 0.8120017041,
+    0.8131983361, 0.8143920230, 0.8155827536, 0.8167705167, 0.8179553012, 0.8191370958,
+    0.8203158896, 0.8214916713, 0.8226644301, 0.8238341547, 0.8250008343, 0.8261644578,
+    0.8273250143, 0.8284824929, 0.8296368828, 0.8307881730, 0.8319363527, 0.8330814112,
+    0.8342233376, 0.8353621213, 0.8364977515, 0.8376302175, 0.8387595088, 0.8398856146,
+    0.8410085244, 0.8421282276, 0.8432447138, 0.8443579723, 0.8454679928, 0.8465747647,
+    0.8476782778, 0.8487785216, 0.8498754857, 0.8509691599, 0.8520595339, 0.8531465974,
+    0.8542303401, 0.8553107520, 0.8563878228, 0.8574615425, 0.8585319008, 0.8595988878,
+    0.8606624934, 0.8617227077, 0.8627795206, 0.8638329222, 0.8648829026, 0.8659294520,
+    0.8669725604, 0.8680122182, 0.8690484154, 0.8700811424, 0.8711103895, 0.8721361469,
+    0.8731584051, 0.8741771544, 0.8751923852, 0.8762040880, 0.8772122533, 0.8782168716,
+    0.8792179335, 0.8802154295, 0.8812093502, 0.8821996864, 0.8831864286, 0.8841695677,
+    0.8851490944, 0.8861249994, 0.8870972736, 0.8880659079, 0.8890308931, 0.8899922202,
+    0.8909498801, 0.8919038639, 0.8928541624, 0.8938007669, 0.8947436684, 0.8956828581,
+    0.8966183271, 0.8975500666, 0.8984780678, 0.8994023221, 0.9003228207, 0.9012395551,
+    0.9021525164, 0.9030616963, 0.9039670861, 0.9048686773, 0.9057664615, 0.9066604301,
+    0.9075505748, 0.9084368873, 0.9093193592, 0.9101979821, 0.9110727479, 0.9119436483,
+    0.9128106750, 0.9136738201, 0.9145330753, 0.9153884325, 0.9162398838, 0.9170874211,
+    0.9179310364, 0.9187707219, 0.9196064696, 0.9204382716, 0.9212661201, 0.9220900075,
+    0.9229099258, 0.9237258674, 0.9245378246, 0.9253457899, 0.9261497555, 0.9269497139,
+    0.9277456577, 0.9285375792, 0.9293254712, 0.9301093261, 0.9308891366, 0.9316648954,
+    0.9324365952, 0.9332042287, 0.9339677886, 0.9347272679, 0.9354826594, 0.9362339559,
+    0.9369811504, 0.9377242359, 0.9384632054, 0.9391980520, 0.9399287687, 0.9406553486,
+    0.9413777850, 0.9420960710, 0.9428101999, 0.9435201650, 0.9442259596, 0.9449275770,
+    0.9456250107, 0.9463182541, 0.9470073006, 0.9476921439, 0.9483727774, 0.9490491948,
+    0.9497213897, 0.9503893558, 0.9510530868, 0.9517125764, 0.9523678185, 0.9530188069,
+    0.9536655355, 0.9543079981, 0.9549461889, 0.9555801016, 0.9562097305, 0.9568350695,
+    0.9574561128, 0.9580728546, 0.9586852890, 0.9592934103, 0.9598972128, 0.9604966908,
+    0.9610918387, 0.9616826508, 0.9622691216, 0.9628512456, 0.9634290173, 0.9640024313,
+    0.9645714822, 0.9651361647, 0.9656964734, 0.9662524030, 0.9668039484, 0.9673511043,
+    0.9678938657, 0.9684322273, 0.9689661842, 0.9694957313, 0.9700208637, 0.9705415763,
+    0.9710578644, 0.9715697230, 0.9720771473, 0.9725801326, 0.9730786742, 0.9735727673,
+    0.9740624073, 0.9745475895, 0.9750283096, 0.9755045628, 0.9759763448, 0.9764436511,
+    0.9769064773, 0.9773648190, 0.9778186720, 0.9782680320, 0.9787128947, 0.9791532560,
+    0.9795891117, 0.9800204578, 0.9804472901, 0.9808696047, 0.9812873975, 0.9817006648,
+    0.9821094025, 0.9825136068, 0.9829132740, 0.9833084002, 0.9836989818, 0.9840850151,
+    0.9844664964, 0.9848434222, 0.9852157889, 0.9855835931, 0.9859468312, 0.9863054998,
+    0.9866595956, 0.9870091153, 0.9873540555, 0.9876944131, 0.9880301847, 0.9883613673,
+    0.9886879578, 0.9890099530, 0.9893273500, 0.9896401457, 0.9899483373, 0.9902519217,
+    0.9905508963, 0.9908452580, 0.9911350043, 0.9914201323, 0.9917006395, 0.9919765230,
+    0.9922477804, 0.9925144091, 0.9927764066, 0.9930337704, 0.9932864982, 0.9935345874,
+    0.9937780359, 0.9940168412, 0.9942510013, 0.9944805137, 0.9947053765, 0.9949255875,
+    0.9951411446, 0.9953520458, 0.9955582891, 0.9957598726, 0.9959567943, 0.9961490524,
+    0.9963366452, 0.9965195708, 0.9966978276, 0.9968714138, 0.9970403278, 0.9972045681,
+    0.9973641330, 0.9975190211, 0.9976692310, 0.9978147612, 0.9979556103, 0.9980917771,
+    0.9982232602, 0.9983500584, 0.9984721705, 0.9985895954, 0.9987023320, 0.9988103791,
+    0.9989137359, 0.9990124013, 0.9991063743, 0.9991956542, 0.9992802400, 0.9993601310,
+    0.9994353264, 0.9995058256, 0.9995716277, 0.9996327323, 0.9996891388, 0.9997408466,
+    0.9997878552, 0.9998301643, 0.9998677733, 0.9999006820, 0.9999288900, 0.9999523970,
+    0.9999712030, 0.9999853076, 0.9999947107, 0.9999994123, 0.9999994123, 0.9999947107,
+    0.9999853076, 0.9999712030, 0.9999523970, 0.9999288900, 0.9999006820, 0.9998677733,
+    0.9998301643, 0.9997878552, 0.9997408466, 0.9996891388, 0.9996327323, 0.9995716277,
+    0.9995058256, 0.9994353264, 0.9993601310, 0.9992802400, 0.9991956542, 0.9991063743,
+    0.9990124013, 0.9989137359, 0.9988103791, 0.9987023320, 0.9985895954, 0.9984721705,
+    0.9983500584, 0.9982232602, 0.9980917771, 0.9979556103, 0.9978147612, 0.9976692310,
+    0.9975190211, 0.9973641330, 0.9972045681, 0.9970403278, 0.9968714138, 0.9966978276,
+    0.9965195708, 0.9963366452, 0.9961490524, 0.9959567943, 0.9957598726, 0.9955582891,
+    0.9953520458, 0.9951411446, 0.9949255875, 0.9947053765, 0.9944805137, 0.9942510013,
+    0.9940168412, 0.9937780359, 0.9935345874, 0.9932864982, 0.9930337704, 0.9927764066,
+    0.9925144091, 0.9922477804, 0.9919765230, 0.9917006395, 0.9914201323, 0.9911350043,
+    0.9908452580, 0.9905508963, 0.9902519217, 0.9899483373, 0.9896401457, 0.9893273500,
+    0.9890099530, 0.9886879578, 0.9883613673, 0.9880301847, 0.9876944131, 0.9873540555,
+    0.9870091153, 0.9866595956, 0.9863054998, 0.9859468312, 0.9855835931, 0.9852157889,
+    0.9848434222, 0.9844664964, 0.9840850151, 0.9836989818, 0.9833084002, 0.9829132740,
+    0.9825136068, 0.9821094025, 0.9817006648, 0.9812873975, 0.9808696047, 0.9804472901,
+    0.9800204578, 0.9795891117, 0.9791532560, 0.9787128947, 0.9782680320, 0.9778186720,
+    0.9773648190, 0.9769064773, 0.9764436511, 0.9759763448, 0.9755045628, 0.9750283096,
+    0.9745475895, 0.9740624073, 0.9735727673, 0.9730786742, 0.9725801326, 0.9720771473,
+    0.9715697230, 0.9710578644, 0.9705415763, 0.9700208637, 0.9694957313, 0.9689661842,
+    0.9684322273, 0.9678938657, 0.9673511043, 0.9668039484, 0.9662524030, 0.9656964734,
+    0.9651361647, 0.9645714822, 0.9640024313, 0.9634290173, 0.9628512456, 0.9622691216,
+    0.9616826508, 0.9610918387, 0.9604966908, 0.9598972128, 0.9592934103, 0.9586852890,
+    0.9580728546, 0.9574561128, 0.9568350695, 0.9562097305, 0.9555801016, 0.9549461889,
+    0.9543079981, 0.9536655355, 0.9530188069, 0.9523678185, 0.9517125764, 0.9510530868,
+    0.9503893558, 0.9497213897, 0.9490491948, 0.9483727774, 0.9476921439, 0.9470073006,
+    0.9463182541, 0.9456250107, 0.9449275770, 0.9442259596, 0.9435201650, 0.9428101999,
+    0.9420960710, 0.9413777850, 0.9406553486, 0.9399287687, 0.9391980520, 0.9384632054,
+    0.9377242359, 0.9369811504, 0.9362339559, 0.9354826594, 0.9347272679, 0.9339677886,
+    0.9332042287, 0.9324365952, 0.9316648954, 0.9308891366, 0.9301093261, 0.9293254712,
+    0.9285375792, 0.9277456577, 0.9269497139, 0.9261497555, 0.9253457899, 0.9245378246,
+    0.9237258674, 0.9229099258, 0.9220900075, 0.9212661201, 0.9204382716, 0.9196064696,
+    0.9187707219, 0.9179310364, 0.9170874211, 0.9162398838, 0.9153884325, 0.9145330753,
+    0.9136738201, 0.9128106750, 0.9119436483, 0.9110727479, 0.9101979821, 0.9093193592,
+    0.9084368873, 0.9075505748, 0.9066604301, 0.9057664615, 0.9048686773, 0.9039670861,
+    0.9030616963, 0.9021525164, 0.9012395551, 0.9003228207, 0.8994023221, 0.8984780678,
+    0.8975500666, 0.8966183271, 0.8956828581, 0.8947436684, 0.8938007669, 0.8928541624,
+    0.8919038639, 0.8909498801, 0.8899922202, 0.8890308931, 0.8880659079, 0.8870972736,
+    0.8861249994, 0.8851490944, 0.8841695677, 0.8831864286, 0.8821996864, 0.8812093502,
+    0.8802154295, 0.8792179335, 0.8782168716, 0.8772122533, 0.8762040880, 0.8751923852,
+    0.8741771544, 0.8731584051, 0.8721361469, 0.8711103895, 0.8700811424, 0.8690484154,
+    0.8680122182, 0.8669725604, 0.8659294520, 0.8648829026, 0.8638329222, 0.8627795206,
+    0.8617227077, 0.8606624934, 0.8595988878, 0.8585319008, 0.8574615425, 0.8563878228,
+    0.8553107520, 0.8542303401, 0.8531465974, 0.8520595339, 0.8509691599, 0.8498754857,
+    0.8487785216, 0.8476782778, 0.8465747647, 0.8454679928, 0.8443579723, 0.8432447138,
+    0.8421282276, 0.8410085244, 0.8398856146, 0.8387595088, 0.8376302175, 0.8364977515,
+    0.8353621213, 0.8342233376, 0.8330814112, 0.8319363527, 0.8307881730, 0.8296368828,
+    0.8284824929, 0.8273250143, 0.8261644578, 0.8250008343, 0.8238341547, 0.8226644301,
+    0.8214916713, 0.8203158896, 0.8191370958, 0.8179553012, 0.8167705167, 0.8155827536,
+    0.8143920230, 0.8131983361, 0.8120017041, 0.8108021384, 0.8095996501, 0.8083942505,
+    0.8071859511, 0.8059747632, 0.8047606981, 0.8035437673, 0.8023239822, 0.8011013543,
+    0.7998758950, 0.7986476160, 0.7974165288, 0.7961826448, 0.7949459759, 0.7937065334,
+    0.7924643292, 0.7912193749, 0.7899716822, 0.7887212629, 0.7874681286, 0.7862122913,
+    0.7849537626, 0.7836925544, 0.7824286786, 0.7811621471, 0.7798929718, 0.7786211646,
+    0.7773467374, 0.7760697023, 0.7747900713, 0.7735078563, 0.7722230696, 0.7709357230,
+    0.7696458288, 0.7683533990, 0.7670584459, 0.7657609816, 0.7644610182, 0.7631585681,
+    0.7618536435, 0.7605462566, 0.7592364197, 0.7579241452, 0.7566094454, 0.7552923326,
+    0.7539728192, 0.7526509177, 0.7513266405, 0.7500000000, 0.7486710087, 0.7473396791,
+    0.7460060237, 0.7446700551, 0.7433317858, 0.7419912284, 0.7406483955, 0.7393032997,
+    0.7379559537, 0.7366063702, 0.7352545618, 0.7339005413, 0.7325443214, 0.7311859148,
+    0.7298253343, 0.7284625927, 0.7270977029, 0.7257306776, 0.7243615297, 0.7229902721,
+    0.7216169176, 0.7202414793, 0.7188639700, 0.7174844027, 0.7161027903, 0.7147191459,
+    0.7133334824, 0.7119458129, 0.7105561504, 0.7091645081, 0.7077708989, 0.7063753360,
+    0.7049778325, 0.7035784016, 0.7021770564, 0.7007738101, 0.6993686758, 0.6979616669,
+    0.6965527965, 0.6951420779, 0.6937295243, 0.6923151490, 0.6908989653, 0.6894809866,
+    0.6880612262, 0.6866396974, 0.6852164136, 0.6837913881, 0.6823646344, 0.6809361660,
+    0.6795059961, 0.6780741383, 0.6766406060, 0.6752054128, 0.6737685721, 0.6723300973,
+    0.6708900022, 0.6694483001, 0.6680050047, 0.6665601294, 0.6651136880, 0.6636656940,
+    0.6622161610, 0.6607651027, 0.6593125326, 0.6578584645, 0.6564029120, 0.6549458889,
+    0.6534874087, 0.6520274853, 0.6505661323, 0.6491033636, 0.6476391928, 0.6461736337,
+    0.6447067001, 0.6432384058, 0.6417687646, 0.6402977903, 0.6388254968, 0.6373518979,
+    0.6358770074, 0.6344008392, 0.6329234073, 0.6314447254, 0.6299648076, 0.6284836676,
+    0.6270013195, 0.6255177772, 0.6240330546, 0.6225471657, 0.6210601245, 0.6195719449,
+    0.6180826410, 0.6165922267, 0.6151007161, 0.6136081231, 0.6121144619, 0.6106197465,
+    0.6091239908, 0.6076272091, 0.6061294153, 0.6046306235, 0.6031308479, 0.6016301025,
+    0.6001284015, 0.5986257590, 0.5971221890, 0.5956177058, 0.5941123235, 0.5926060563,
+    0.5910989182, 0.5895909235, 0.5880820864, 0.5865724210, 0.5850619416, 0.5835506623,
+    0.5820385974, 0.5805257610, 0.5790121675, 0.5774978309, 0.5759827657, 0.5744669860,
+    0.5729505060, 0.5714333401, 0.5699155024, 0.5683970074, 0.5668778692, 0.5653581021,
+    0.5638377205, 0.5623167385, 0.5607951706, 0.5592730311, 0.5577503341, 0.5562270942,
+    0.5547033255, 0.5531790424, 0.5516542593, 0.5501289905, 0.5486032503, 0.5470770530,
+    0.5455504131, 0.5440233449, 0.5424958627, 0.5409679809, 0.5394397139, 0.5379110760,
+    0.5363820817, 0.5348527452, 0.5333230810, 0.5317931035, 0.5302628270, 0.5287322659,
+    0.5272014347, 0.5256703477, 0.5241390193, 0.5226074639, 0.5210756959, 0.5195437298,
+    0.5180115799, 0.5164792606, 0.5149467863, 0.5134141715, 0.5118814306, 0.5103485780,
+    0.5088156280, 0.5072825951, 0.5057494938, 0.5042163384, 0.5026831434, 0.5011499231,
+    0.4996166920, 0.4980834645, 0.4965502551, 0.4950170780, 0.4934839479, 0.4919508790,
+    0.4904178858, 0.4888849827, 0.4873521841, 0.4858195044, 0.4842869581, 0.4827545595,
+    0.4812223231, 0.4796902633, 0.4781583944, 0.4766267310, 0.4750952873, 0.4735640778,
+    0.4720331168, 0.4705024189, 0.4689719983, 0.4674418695, 0.4659120468, 0.4643825447,
+    0.4628533775, 0.4613245596, 0.4597961053, 0.4582680291, 0.4567403454, 0.4552130684,
+    0.4536862125, 0.4521597921, 0.4506338216, 0.4491083153, 0.4475832875, 0.4460587526,
+    0.4445347250, 0.4430112189, 0.4414882486, 0.4399658286, 0.4384439731, 0.4369226964,
+    0.4354020128, 0.4338819366, 0.4323624822, 0.4308436638, 0.4293254957, 0.4278079921,
+    0.4262911674, 0.4247750358, 0.4232596115, 0.4217449088, 0.4202309420, 0.4187177253,
+    0.4172052728, 0.4156935990, 0.4141827178, 0.4126726436, 0.4111633906, 0.4096549729,
+    0.4081474048, 0.4066407004, 0.4051348738, 0.4036299393, 0.4021259109, 0.4006228029,
+    0.3991206294, 0.3976194044, 0.3961191422, 0.3946198567, 0.3931215622, 0.3916242727,
+    0.3901280022, 0.3886327649, 0.3871385748, 0.3856454460, 0.3841533924, 0.3826624282,
+    0.3811725674, 0.3796838239, 0.3781962117, 0.3767097449, 0.3752244374, 0.3737403032,
+    0.3722573563, 0.3707756105, 0.3692950799, 0.3678157783, 0.3663377196, 0.3648609179,
+    0.3633853868, 0.3619111404, 0.3604381924, 0.3589665568, 0.3574962473, 0.3560272778,
+    0.3545596622, 0.3530934141, 0.3516285474, 0.3501650759, 0.3487030133, 0.3472423734,
+    0.3457831699, 0.3443254166, 0.3428691270, 0.3414143150, 0.3399609943, 0.3385091784,
+    0.3370588810, 0.3356101158, 0.3341628964, 0.3327172363, 0.3312731493, 0.3298306489,
+    0.3283897485, 0.3269504619, 0.3255128025, 0.3240767838, 0.3226424194, 0.3212097227,
+    0.3197787071, 0.3183493863, 0.3169217735, 0.3154958823, 0.3140717260, 0.3126493180,
+    0.3112286717, 0.3098098005, 0.3083927176, 0.3069774365, 0.3055639704, 0.3041523326,
+    0.3027425364, 0.3013345951, 0.2999285219, 0.2985243300, 0.2971220325, 0.2957216428,
+    0.2943231740, 0.2929266392, 0.2915320515, 0.2901394241, 0.2887487700, 0.2873601024,
+    0.2859734343, 0.2845887787, 0.2832061487, 0.2818255572, 0.2804470173, 0.2790705418,
+    0.2776961439, 0.2763238362, 0.2749536319, 0.2735855437, 0.2722195845, 0.2708557672,
+    0.2694941045, 0.2681346094, 0.2667772945, 0.2654221727, 0.2640692567, 0.2627185591,
+    0.2613700928, 0.2600238703, 0.2586799044, 0.2573382077, 0.2559987928, 0.2546616722,
+    0.2533268587, 0.2519943646, 0.2506642026, 0.2493363851, 0.2480109247, 0.2466878338,
+    0.2453671248, 0.2440488102, 0.2427329023, 0.2414194136, 0.2401083564, 0.2387997429,
+    0.2374935856, 0.2361898967, 0.2348886885, 0.2335899731, 0.2322937629, 0.2310000699,
+    0.2297089064, 0.2284202845, 0.2271342163, 0.2258507140, 0.2245697895, 0.2232914549,
+    0.2220157223, 0.2207426036, 0.2194721108, 0.2182042559, 0.2169390508, 0.2156765073,
+    0.2144166374, 0.2131594529, 0.2119049656, 0.2106531873, 0.2094041298, 0.2081578049,
+    0.2069142242, 0.2056733994, 0.2044353422, 0.2032000643, 0.2019675773, 0.2007378927,
+    0.1995110222, 0.1982869772, 0.1970657692, 0.1958474098, 0.1946319104, 0.1934192825,
+    0.1922095374, 0.1910026865, 0.1897987412, 0.1885977127, 0.1873996124, 0.1862044516,
+    0.1850122415, 0.1838229932, 0.1826367180, 0.1814534271, 0.1802731315, 0.1790958423,
+    0.1779215707, 0.1767503277, 0.1755821242, 0.1744169713, 0.1732548799, 0.1720958610,
+    0.1709399254, 0.1697870840, 0.1686373477, 0.1674907272, 0.1663472334, 0.1652068770,
+    0.1640696688, 0.1629356193, 0.1618047394, 0.1606770395, 0.1595525304, 0.1584312225,
+    0.1573131265, 0.1561982529, 0.1550866121, 0.1539782145, 0.1528730707, 0.1517711910,
+    0.1506725857, 0.1495772653, 0.1484852399, 0.1473965199, 0.1463111155, 0.1452290369,
+    0.1441502943, 0.1430748978, 0.1420028576, 0.1409341836, 0.1398688861, 0.1388069749,
+    0.1377484601, 0.1366933516, 0.1356416593, 0.1345933932, 0.1335485631, 0.1325071788,
+    0.1314692500, 0.1304347867, 0.1294037985, 0.1283762950, 0.1273522860, 0.1263317811,
+    0.1253147898, 0.1243013218, 0.1232913866, 0.1222849936, 0.1212821523, 0.1202828722,
+    0.1192871627, 0.1182950331, 0.1173064927, 0.1163215508, 0.1153402168, 0.1143624998,
+    0.1133884090, 0.1124179537, 0.1114511428, 0.1104879855, 0.1095284909, 0.1085726679,
+    0.1076205257, 0.1066720730, 0.1057273189, 0.1047862722, 0.1038489418, 0.1029153364,
+    0.1019854650, 0.1010593361, 0.1001369586, 0.0992183410, 0.0983034921, 0.0973924204,
+    0.0964851345, 0.0955816430, 0.0946819542, 0.0937860768, 0.0928940190, 0.0920057894,
+    0.0911213962, 0.0902408477, 0.0893641523, 0.0884913182, 0.0876223536, 0.0867572667,
+    0.0858960656, 0.0850387583, 0.0841853531, 0.0833358578, 0.0824902805, 0.0816486291,
+    0.0808109116, 0.0799771357, 0.0791473095, 0.0783214406, 0.0774995368, 0.0766816058,
+    0.0758676555, 0.0750576933, 0.0742517269, 0.0734497639, 0.0726518119, 0.0718578783,
+    0.0710679706, 0.0702820963, 0.0695002626, 0.0687224770, 0.0679487469, 0.0671790793,
+    0.0664134817, 0.0656519612, 0.0648945250, 0.0641411801, 0.0633919337, 0.0626467928,
+    0.0619057644, 0.0611688555, 0.0604360730, 0.0597074238, 0.0589829148, 0.0582625528,
+    0.0575463445, 0.0568342966, 0.0561264160, 0.0554227092, 0.0547231828, 0.0540278434,
+    0.0533366976, 0.0526497519, 0.0519670127, 0.0512884865, 0.0506141795, 0.0499440982,
+    0.0492782489, 0.0486166378, 0.0479592712, 0.0473061552, 0.0466572959, 0.0460126996,
+    0.0453723721, 0.0447363196, 0.0441045481, 0.0434770634, 0.0428538715, 0.0422349782,
+    0.0416203894, 0.0410101108, 0.0404041482, 0.0398025073, 0.0392051936, 0.0386122130,
+    0.0380235708, 0.0374392727, 0.0368593242, 0.0362837306, 0.0357124975, 0.0351456301,
+    0.0345831339, 0.0340250141, 0.0334712759, 0.0329219246, 0.0323769653, 0.0318364032,
+    0.0313002433, 0.0307684907, 0.0302411503, 0.0297182272, 0.0291997263, 0.0286856523,
+    0.0281760103, 0.0276708049, 0.0271700408, 0.0266737229, 0.0261818558, 0.0256944441,
+    0.0252114924, 0.0247330052, 0.0242589870, 0.0237894423, 0.0233243755, 0.0228637910,
+    0.0224076931, 0.0219560861, 0.0215089742, 0.0210663617, 0.0206282527, 0.0201946513,
+    0.0197655616, 0.0193409877, 0.0189209335, 0.0185054029, 0.0180944000, 0.0176879285,
+    0.0172859922, 0.0168885951, 0.0164957407, 0.0161074328, 0.0157236751, 0.0153444710,
+    0.0149698243, 0.0145997385, 0.0142342169, 0.0138732631, 0.0135168805, 0.0131650723,
+    0.0128178420, 0.0124751927, 0.0121371277, 0.0118036501, 0.0114747632, 0.0111504700,
+    0.0108307735, 0.0105156768, 0.0102051828, 0.0098992944, 0.0095980146, 0.0093013461,
+    0.0090092917, 0.0087218542, 0.0084390363, 0.0081608407, 0.0078872699, 0.0076183265,
+    0.0073540131, 0.0070943321, 0.0068392860, 0.0065888773, 0.0063431081, 0.0061019809,
+    0.0058654980, 0.0056336614, 0.0054064735, 0.0051839364, 0.0049660521, 0.0047528227,
+    0.0045442502, 0.0043403366, 0.0041410837, 0.0039464936, 0.0037565679, 0.0035713085,
+    0.0033907171, 0.0032147954, 0.0030435451, 0.0028769677, 0.0027150650, 0.0025578382,
+    0.0024052891, 0.0022574189, 0.0021142290, 0.0019757209, 0.0018418958, 0.0017127550,
+    0.0015882997, 0.0014685311, 0.0013534502, 0.0012430582, 0.0011373561, 0.0010363449,
+    0.0009400256, 0.0008483991, 0.0007614661, 0.0006792276, 0.0006016843, 0.0005288369,
+    0.0004606862, 0.0003972327, 0.0003384771, 0.0002844199, 0.0002350617, 0.0001904028,
+    0.0001504437, 0.0001151848, 0.0000846264, 0.0000587689, 0.0000376123, 0.0000211571,
+    0.0000094032, 0.0000023508};
+
+#endif // LIB_UTILS_HANNING_H_
diff --git a/app/src/main/cpp/vibrafp/lib/utils/ring_buffer.h b/app/src/main/cpp/vibrafp/lib/utils/ring_buffer.h
new file mode 100644
index 0000000000..82c28fc058
--- /dev/null
+++ b/app/src/main/cpp/vibrafp/lib/utils/ring_buffer.h
@@ -0,0 +1,69 @@
+#ifndef LIB_UTILS_RING_BUFFER_H_
+#define LIB_UTILS_RING_BUFFER_H_
+
+#include <vector>
+
+template <typename T> class RingBuffer : private std::vector<T>
+{
+public:
+    explicit RingBuffer(std::size_t size, T &&default_value = T());
+    virtual ~RingBuffer();
+
+    void Append(const T &value);
+    std::uint32_t size() const
+    {
+        return std::vector<T>::size();
+    }
+    std::uint32_t &num_written()
+    {
+        return num_written_;
+    }
+    std::uint32_t &position()
+    {
+        return position_;
+    }
+
+    T &operator[](std::int32_t index);
+
+    typename std::vector<T>::iterator begin()
+    {
+        return std::vector<T>::begin();
+    }
+    typename std::vector<T>::iterator end()
+    {
+        return std::vector<T>::end();
+    }
+
+private:
+    std::uint32_t num_written_;
+    std::uint32_t position_;
+};
+
+template <typename T> T &RingBuffer<T>::operator[](std::int32_t index)
+{
+    if (index < 0)
+    {
+        index = std::vector<T>::size() + index;
+        // support negative index
+    }
+    return std::vector<T>::operator[](index);
+}
+
+template <typename T>
+RingBuffer<T>::RingBuffer(std::size_t size, T &&default_value)
+    : std::vector<T>(size, default_value), num_written_(0), position_(0)
+{
+}
+
+template <typename T> RingBuffer<T>::~RingBuffer()
+{
+}
+
+template <typename T> void RingBuffer<T>::Append(const T &value)
+{
+    this->operator[](position_) = value;
+    position_ = (position_ + 1) % std::vector<T>::size();
+    num_written_++;
+}
+
+#endif // LIB_UTILS_RING_BUFFER_H_
diff --git a/app/src/main/cpp/vibrafp/lib/vibra.cpp b/app/src/main/cpp/vibrafp/lib/vibra.cpp
new file mode 100644
index 0000000000..46c5fc7878
--- /dev/null
+++ b/app/src/main/cpp/vibrafp/lib/vibra.cpp
@@ -0,0 +1,67 @@
+#include "../include/vibra.h"
+#include "algorithm/signature_generator.h"
+#include "audio/downsampler.h"
+#include "audio/wav.h"
+
+constexpr std::uint32_t MAX_DURATION_SECONDS = 12;
+
+Fingerprint *_get_fingerprint_from_wav(const Wav &wav);
+
+Fingerprint *_get_fingerprint_from_low_quality_pcm(const LowQualityTrack &pcm);
+
+Fingerprint *vibra_get_fingerprint_from_wav_data(const char *raw_wav, int wav_data_size)
+{
+    Wav wav = Wav::FromRawWav(raw_wav, wav_data_size);
+    return _get_fingerprint_from_wav(wav);
+}
+
+Fingerprint *vibra_get_fingerprint_from_signed_pcm(const char *raw_pcm, int pcm_data_size,
+                                                   int sample_rate, int sample_width,
+                                                   int channel_count)
+{
+    Wav wav = Wav::FromSignedPCM(raw_pcm, pcm_data_size, sample_rate, sample_width, channel_count);
+    return _get_fingerprint_from_wav(wav);
+}
+
+Fingerprint *vibra_get_fingerprint_from_float_pcm(const char *raw_pcm, int pcm_data_size,
+                                                  int sample_rate, int sample_width,
+                                                  int channel_count)
+{
+    Wav wav = Wav::FromFloatPCM(raw_pcm, pcm_data_size, sample_rate, sample_width, channel_count);
+    return _get_fingerprint_from_wav(wav);
+}
+
+const char *vibra_get_uri_from_fingerprint(Fingerprint *fingerprint)
+{
+    return fingerprint->uri.c_str();
+}
+
+unsigned int vibra_get_sample_ms_from_fingerprint(Fingerprint *fingerprint)
+{
+    return fingerprint->sample_ms;
+}
+
+void vibra_free_fingerprint(Fingerprint *fingerprint)
+{
+    delete fingerprint;
+}
+
+Fingerprint *_get_fingerprint_from_wav(const Wav &wav)
+{
+    LowQualityTrack pcm = Downsampler::GetLowQualityPCM(wav);
+    return _get_fingerprint_from_low_quality_pcm(pcm);
+}
+
+Fingerprint *_get_fingerprint_from_low_quality_pcm(const LowQualityTrack &pcm)
+{
+    SignatureGenerator generator;
+    generator.FeedInput(pcm);
+    generator.set_max_time_seconds(MAX_DURATION_SECONDS);
+
+    Signature signature = generator.GetNextSignature();
+
+    Fingerprint *fingerprint = new Fingerprint;
+    fingerprint->uri = signature.EncodeBase64();
+    fingerprint->sample_ms = signature.num_samples() * 1000 / signature.sample_rate();
+    return fingerprint;
+}
diff --git a/app/src/main/cpp/vibrafp/lib/vibra.sym b/app/src/main/cpp/vibrafp/lib/vibra.sym
new file mode 100644
index 0000000000..0b8e04d651
--- /dev/null
+++ b/app/src/main/cpp/vibrafp/lib/vibra.sym
@@ -0,0 +1,6 @@
+{
+  global:
+    Java_com_metrolist_music_recognition_VibraSignature_*;
+  local:
+    *;
+};
\ No newline at end of file
diff --git a/app/src/main/cpp/vibrafp/lib/vibra_jni.cpp b/app/src/main/cpp/vibrafp/lib/vibra_jni.cpp
new file mode 100644
index 0000000000..79513f1521
--- /dev/null
+++ b/app/src/main/cpp/vibrafp/lib/vibra_jni.cpp
@@ -0,0 +1,67 @@
+#include <jni.h>
+#include <string>
+#include "../include/vibra.h"
+
+extern "C"
+JNIEXPORT jstring JNICALL
+Java_com_metrolist_music_recognition_VibraSignature_fromI16(JNIEnv *env, jclass /*clazz*/, jbyteArray rawPcm) {
+    if (rawPcm == nullptr) {
+        jclass iae = env->FindClass("java/lang/IllegalArgumentException");
+        if (iae) env->ThrowNew(iae, "rawPcm must not be null");
+        return nullptr;
+    }
+    jbyte *pcmData = env->GetByteArrayElements(rawPcm, nullptr);
+    if (pcmData == nullptr) {
+        if (!env->ExceptionCheck()) {
+            jclass rte = env->FindClass("java/lang/RuntimeException");
+            if (rte) env->ThrowNew(rte, "GetByteArrayElements returned null");
+        }
+        return nullptr;
+    }
+    jsize size = env->GetArrayLength(rawPcm);
+    try {
+        Fingerprint *fp = vibra_get_fingerprint_from_signed_pcm(
+                reinterpret_cast<const char *>(pcmData),
+                static_cast<int>(size),
+                /*sample rate*/ 16000,
+                /*bits per sample*/16,
+                /*channels*/1
+        );
+        env->ReleaseByteArrayElements(rawPcm, pcmData, JNI_ABORT);
+        if (fp == nullptr) {
+            if (!env->ExceptionCheck()) {
+                jclass rte = env->FindClass("java/lang/RuntimeException");
+                if (rte) env->ThrowNew(rte, "Failed to generate fingerprint from signed PCM");
+            }
+            return nullptr;
+        }
+        std::string uri = fp->uri;
+        unsigned int sample_ms = fp->sample_ms;
+        vibra_free_fingerprint(fp);
+        jstring result = env->NewStringUTF(uri.c_str());
+//        std::string json = R"({"uri":")" + uri + R"(","sample_ms":)" + std::to_string(sample_ms) + "}";
+//        jstring result = env->NewStringUTF(json.c_str());
+        if (result == nullptr) {
+            if (!env->ExceptionCheck()) {
+                jclass oom = env->FindClass("java/lang/OutOfMemoryError");
+                if (oom) env->ThrowNew(oom, "Failed to allocate result string");
+            }
+            return nullptr;
+        }
+        return result;
+    } catch (const std::exception& e) {
+        env->ReleaseByteArrayElements(rawPcm, pcmData, JNI_ABORT);
+        if (!env->ExceptionCheck()) {
+            jclass rte = env->FindClass("java/lang/RuntimeException");
+            if (rte) env->ThrowNew(rte, e.what());
+        }
+        return nullptr;
+    } catch (...) {
+        env->ReleaseByteArrayElements(rawPcm, pcmData, JNI_ABORT);
+        if (!env->ExceptionCheck()) {
+            jclass rte = env->FindClass("java/lang/RuntimeException");
+            if (rte) env->ThrowNew(rte, "Unknown error in native fingerprint generation");
+        }
+        return nullptr;
+    }
+}
diff --git a/app/src/main/cpp/vibrafp/third_party/build-fftw-android.sh b/app/src/main/cpp/vibrafp/third_party/build-fftw-android.sh
new file mode 100644
index 0000000000..74e222aa17
--- /dev/null
+++ b/app/src/main/cpp/vibrafp/third_party/build-fftw-android.sh
@@ -0,0 +1,263 @@
+#!/usr/bin/env bash
+set -euo pipefail
+
+########################################################
+# build-fftw-android.sh
+# Downloads FFTW sources and builds static libfftw3.a for Android ABIs and installs into:
+#   <OUT_BASE>/<android_abi>/(include|lib)
+#
+# Defaults:
+#  - Path to Android NDK: ANDROID_NDK_HOME
+#  - Output install root: ./fftw-android
+#  - FFTW version: 3.3.10
+#  - API: 26
+#  - ABIS: arm64, armv7-a, x86_64, x86
+#
+# Usage:
+#   ./build-fftw-android.sh
+#   ./build-fftw-android.sh --ndk /path/to/ndk --out /tmp/out --version 3.3.10 --api 26
+########################################################
+
+# Defaults
+FFTW_VERSION="${FFTW_VERSION:-3.3.10}"
+FFTW_BASE_URL="${FFTW_BASE_URL:-https://www.fftw.org}"
+FFTW_TARBALL="fftw-${FFTW_VERSION}.tar.gz"
+FFTW_URL="${FFTW_BASE_URL}/${FFTW_TARBALL}"
+OUT_BASE_DEFAULT="$(pwd)/fftw-android"
+OUT_BASE="${OUT_BASE:-$OUT_BASE_DEFAULT}"
+API="${API:-26}"
+
+DEFAULT_ARCHS=("arm64" "armv7-a" "x86_64" "x86")
+ARCHS=("${DEFAULT_ARCHS[@]}")
+
+NDK_DIR="${ANDROID_NDK_HOME:-}"
+
+usage() {
+  cat <<EOF
+Usage: $0 [options]
+
+Options:
+  --ndk PATH         Path to Android NDK (or set ANDROID_NDK_HOME)
+  --out PATH         Output install root (default: ${OUT_BASE_DEFAULT})
+  --version VER      FFTW version (default: ${FFTW_VERSION})
+  --api N            Android API level used for clang (default: ${API})
+  --archs a,b,c      Comma-separated subset of: ${DEFAULT_ARCHS[*]}
+  --help             Show this help
+EOF
+  exit 1
+}
+
+# Parse CLI
+while [[ $# -gt 0 ]]; do
+  case "$1" in
+    --ndk) NDK_DIR="$2"; shift 2;;
+    --out) OUT_BASE="$2"; shift 2;;
+    --version) FFTW_VERSION="$2"; FFTW_TARBALL="fftw-${FFTW_VERSION}.tar.gz"; FFTW_URL="${FFTW_BASE_URL}/${FFTW_TARBALL}"; shift 2;;
+    --api) API="$2"; shift 2;;
+    --archs) IFS=',' read -r -a ARCHS <<< "$2"; shift 2;;
+    --help|-h) usage;;
+    *) echo "Unknown argument: $1"; usage;;
+  esac
+done
+
+echo "FFTW version: ${FFTW_VERSION}"
+echo "FFTW URL: ${FFTW_URL}"
+echo "Output install root: ${OUT_BASE}"
+echo "Android API: ${API}"
+echo "Archs: ${ARCHS[*]}"
+echo
+
+# Validate NDK
+if [[ -z "${NDK_DIR}" ]]; then
+  if [[ -n "${ANDROID_NDK_HOME:-}" ]]; then
+    NDK_DIR="${ANDROID_NDK_HOME}"
+  else
+    echo "ERROR: Android NDK not detected. Set ANDROID_NDK_HOME or pass --ndk /path/to/android-ndk"
+    exit 1
+  fi
+fi
+
+NDK_DIR="$(realpath "${NDK_DIR}")"
+PREBUILD="$NDK_DIR/toolchains/llvm/prebuilt/linux-x86_64"
+
+if [[ ! -d "$PREBUILD" ]]; then
+  echo "ERROR: NDK toolchain not found at $PREBUILD"
+  exit 1
+fi
+
+mkdir -p "$OUT_BASE"
+WORKDIR="$(pwd)/.build-fftw"
+rm -rf "$WORKDIR"
+mkdir -p "$WORKDIR"
+cd "$WORKDIR"
+
+TARBALL_PATH="${WORKDIR}/${FFTW_TARBALL}"
+MD5_URL="${FFTW_URL}.md5sum"
+MD5_PATH="${WORKDIR}/${FFTW_TARBALL}.md5sum"
+
+# Download tarball if absent
+if [[ -f "${TARBALL_PATH}" ]]; then
+  echo "Tarball already exists: ${TARBALL_PATH}"
+else
+  echo "Downloading ${FFTW_URL} ..."
+  if command -v curl >/dev/null 2>&1; then
+    curl -fSL -o "${TARBALL_PATH}" "${FFTW_URL}"
+  elif command -v wget >/dev/null 2>&1; then
+    wget -O "${TARBALL_PATH}" "${FFTW_URL}"
+  else
+    echo "ERROR: need curl or wget to download sources"
+    exit 1
+  fi
+fi
+
+# Download md5sum
+echo "Downloading MD5 checksum from ${MD5_URL} ..."
+if command -v curl >/dev/null 2>&1; then
+  curl -fSL -o "${MD5_PATH}" "${MD5_URL}"
+elif command -v wget >/dev/null 2>&1; then
+  wget -O "${MD5_PATH}" "${MD5_URL}"
+fi
+
+if [[ ! -f "${MD5_PATH}" ]]; then
+  echo "ERROR: failed to download MD5 checksum from ${MD5_URL}"
+  exit 1
+fi
+
+# Parse MD5 from file
+EXPECTED_MD5="$(tr -d '\r\n' < "${MD5_PATH}" | sed -E 's/.*([a-fA-F0-9]{32}).*/\1/')"
+if [[ -z "${EXPECTED_MD5}" ]]; then
+  echo "ERROR: could not parse MD5 from ${MD5_PATH}"
+  exit 1
+fi
+
+echo "Expected MD5: ${EXPECTED_MD5}"
+
+# Compute local MD5
+compute_md5() {
+  command -v md5sum >/dev/null 2>&1 || { echo "ERROR: md5sum not found" >&2; return 1; }
+  md5sum "$1" | awk '{print $1}'
+}
+
+LOCAL_MD5="$(compute_md5 "${TARBALL_PATH}")"
+echo "Local  MD5: ${LOCAL_MD5}"
+
+if [[ "${LOCAL_MD5,,}" != "${EXPECTED_MD5,,}" ]]; then
+  echo "ERROR: MD5 mismatch! Download may be corrupted."
+  rm -f "${TARBALL_PATH}"
+  exit 1
+fi
+echo "MD5 verified OK."
+
+# Extract
+echo "Extracting ${TARBALL_PATH}..."
+tar -xzf "${TARBALL_PATH}"
+SRC_DIR="${WORKDIR}/fftw-${FFTW_VERSION}"
+if [[ ! -d "${SRC_DIR}" ]]; then
+  echo "ERROR: expected source dir ${SRC_DIR} not found after extraction"
+  exit 1
+fi
+
+# mapping: arch key -> triple + android ABI
+declare -A TRIPLE_MAP
+declare -A ABI_MAP
+TRIPLE_MAP["arm64"]="aarch64-linux-android"
+ABI_MAP["arm64"]="arm64-v8a"
+
+TRIPLE_MAP["armv7-a"]="armv7a-linux-androideabi"
+ABI_MAP["armv7-a"]="armeabi-v7a"
+
+TRIPLE_MAP["x86_64"]="x86_64-linux-android"
+ABI_MAP["x86_64"]="x86_64"
+
+TRIPLE_MAP["x86"]="i686-linux-android"
+ABI_MAP["x86"]="x86"
+
+# Tools from NDK
+AR="$PREBUILD/bin/llvm-ar"
+RANLIB="$PREBUILD/bin/llvm-ranlib"
+STRIP="$PREBUILD/bin/llvm-strip"
+
+CPU_COUNT="$(nproc || echo 1)"
+
+echo
+echo "=== Building FFTW for ABIs: ${ARCHS[*]} ==="
+echo
+
+for ARCH in "${ARCHS[@]}"; do
+  if [[ -z "${TRIPLE_MAP[$ARCH]:-}" ]]; then
+    echo "Skipping unknown arch: ${ARCH}"
+    continue
+  fi
+
+  TRIPLE="${TRIPLE_MAP[$ARCH]}"
+  ANDROID_ABI="${ABI_MAP[$ARCH]}"
+  echo ">>> Building for ${ARCH} (ABI=${ANDROID_ABI}, triple=${TRIPLE}, API=${API})"
+
+  TOOLCHAIN="$PREBUILD"
+  SYSROOT="$TOOLCHAIN/sysroot"
+
+  export CC="$TOOLCHAIN/bin/${TRIPLE}${API}-clang"
+  export CXX="$TOOLCHAIN/bin/${TRIPLE}${API}-clang++"
+  export AR="$TOOLCHAIN/bin/llvm-ar"
+  export AS="$TOOLCHAIN/bin/llvm-as"
+  export LD="$TOOLCHAIN/bin/ld.lld"
+  export RANLIB="$TOOLCHAIN/bin/llvm-ranlib"
+  export STRIP="$TOOLCHAIN/bin/llvm-strip"
+
+  base_cflags="--sysroot=${SYSROOT} -O2 -ffunction-sections -fdata-sections -fvisibility=hidden -fPIC -fomit-frame-pointer"
+  LTO_FLAGS="-flto=thin"
+
+  CFLAGS="${base_cflags} ${LTO_FLAGS}"
+  CXXFLAGS="${CFLAGS}"
+  LDFLAGS="-Wl,--gc-sections ${LTO_FLAGS} -Wl,-z,relro -Wl,-z,now"
+
+  export CFLAGS CXXFLAGS LDFLAGS
+
+  INSTALL_DIR="${OUT_BASE}/${ANDROID_ABI}"
+  BUILD_DIR="${WORKDIR}/build-${ANDROID_ABI}"
+  rm -rf "${BUILD_DIR}"
+  mkdir -p "${BUILD_DIR}"
+  mkdir -p "${INSTALL_DIR}"
+
+  pushd "${BUILD_DIR}" >/dev/null
+
+  CONFIG_CMD=(
+    "${SRC_DIR}/configure"
+    --host="${TRIPLE}"
+    --prefix="${INSTALL_DIR}"
+    LIBS="-lc"
+    --enable-static
+    --disable-shared
+    --disable-fortran
+    --disable-maintainer-mode
+    --disable-debug
+  )
+
+  echo "Configuring: ${CONFIG_CMD[*]}"
+  "${CONFIG_CMD[@]}"
+
+  echo "make -j${CPU_COUNT}"
+  make -j"${CPU_COUNT}"
+  make install
+
+  echo "Stripping static libs in ${INSTALL_DIR}/lib ..."
+  set +e
+  $STRIP --strip-unneeded "${INSTALL_DIR}/lib/"*.a 2>/dev/null || true
+  set -e
+
+  popd >/dev/null
+
+  # Cleanup build dir
+  rm -rf "${BUILD_DIR}"
+
+  echo "Installed ABI ${ANDROID_ABI} -> ${INSTALL_DIR}"
+  echo
+done
+
+# Cleanup sources and tarball
+rm -rf "${SRC_DIR}"
+rm -f "${TARBALL_PATH}" "${MD5_PATH}"
+# Remove workdir (it should be empty now)
+rmdir "${WORKDIR}" >/dev/null 2>&1 || true
+
+echo "FFTW compiled. Install root: ${OUT_BASE}"
diff --git a/app/src/main/kotlin/com/metrolist/music/MainActivity.kt b/app/src/main/kotlin/com/metrolist/music/MainActivity.kt
index f381171338..5cbe7a45c3 100644
--- a/app/src/main/kotlin/com/metrolist/music/MainActivity.kt
+++ b/app/src/main/kotlin/com/metrolist/music/MainActivity.kt
@@ -856,6 +856,14 @@ class MainActivity : ComponentActivity() {
                                     }
                                 }
                             }
+                            
+                            val onSearchLongClick: () -> Unit = remember(navController) {
+                                {
+                                    navController.navigate("recognition") {
+                                        launchSingleTop = true
+                                    }
+                                }
+                            }
 
                             // Pre-calculate values for graphicsLayer to avoid reading state during composition
                             val navBarTotalHeight = bottomInset + NavigationBarHeight
@@ -874,6 +882,7 @@ class MainActivity : ComponentActivity() {
                                         onItemClick = onNavItemClick,
                                         pureBlack = pureBlack,
                                         slimNav = slimNav,
+                                        onSearchLongClick = onSearchLongClick,
                                         modifier = Modifier
                                             .align(Alignment.BottomCenter)
                                             .height(bottomInset + navPadding)
@@ -959,12 +968,21 @@ class MainActivity : ComponentActivity() {
                                 }
                             }
 
+                            val onRailSearchLongClick: () -> Unit = remember(navController) {
+                                {
+                                    navController.navigate("recognition") {
+                                        launchSingleTop = true
+                                    }
+                                }
+                            }
+
                             if (showRail && currentRoute != "wrapped") {
                                 AppNavigationRail(
                                     navigationItems = navigationItems,
                                     currentRoute = currentRoute,
                                     onItemClick = onRailItemClick,
-                                    pureBlack = pureBlack
+                                    pureBlack = pureBlack,
+                                    onSearchLongClick = onRailSearchLongClick
                                 )
                             }
                             Box(Modifier.weight(1f)) {
diff --git a/app/src/main/kotlin/com/metrolist/music/db/DatabaseDao.kt b/app/src/main/kotlin/com/metrolist/music/db/DatabaseDao.kt
index b09202fb83..1a4f745ee2 100644
--- a/app/src/main/kotlin/com/metrolist/music/db/DatabaseDao.kt
+++ b/app/src/main/kotlin/com/metrolist/music/db/DatabaseDao.kt
@@ -41,6 +41,7 @@ import com.metrolist.music.db.entities.Playlist
 import com.metrolist.music.db.entities.PlaylistEntity
 import com.metrolist.music.db.entities.PlaylistSong
 import com.metrolist.music.db.entities.PlaylistSongMap
+import com.metrolist.music.db.entities.RecognitionHistory
 import com.metrolist.music.db.entities.RelatedSongMap
 import com.metrolist.music.db.entities.SearchHistory
 import com.metrolist.music.db.entities.SetVideoIdEntity
@@ -1144,6 +1145,37 @@ interface DatabaseDao {
     @Query("DELETE FROM search_history")
     fun clearSearchHistory()
 
+    // Recognition History
+    @Transaction
+    @Query("SELECT * FROM recognition_history ORDER BY recognizedAt DESC")
+    fun recognitionHistory(): Flow<List<RecognitionHistory>>
+
+    @Transaction
+    @Query("SELECT * FROM recognition_history WHERE id = :id")
+    fun recognitionHistoryById(id: Long): Flow<RecognitionHistory?>
+
+    @Transaction
+    @Query("SELECT * FROM recognition_history WHERE title LIKE '%' || :query || '%' OR artist LIKE '%' || :query || '%' ORDER BY recognizedAt DESC")
+    fun searchRecognitionHistory(query: String): Flow<List<RecognitionHistory>>
+
+    @Transaction
+    @Query("DELETE FROM recognition_history")
+    fun clearRecognitionHistory()
+
+    @Transaction
+    @Query("DELETE FROM recognition_history WHERE id = :id")
+    fun deleteRecognitionHistoryById(id: Long)
+
+    @Transaction
+    @Query("UPDATE recognition_history SET liked = :liked WHERE id = :id")
+    fun updateRecognitionHistoryLiked(id: Long, liked: Boolean)
+
+    @Insert(onConflict = OnConflictStrategy.REPLACE)
+    fun insert(recognitionHistory: RecognitionHistory): Long
+
+    @Delete
+    fun delete(recognitionHistory: RecognitionHistory)
+
     @Query("UPDATE song SET totalPlayTime = totalPlayTime + :playTime WHERE id = :songId")
     fun incrementTotalPlayTime(songId: String, playTime: Long)
 
diff --git a/app/src/main/kotlin/com/metrolist/music/db/MusicDatabase.kt b/app/src/main/kotlin/com/metrolist/music/db/MusicDatabase.kt
index 983791a793..6ee0237f7a 100644
--- a/app/src/main/kotlin/com/metrolist/music/db/MusicDatabase.kt
+++ b/app/src/main/kotlin/com/metrolist/music/db/MusicDatabase.kt
@@ -31,6 +31,7 @@ import com.metrolist.music.db.entities.PlayCountEntity
 import com.metrolist.music.db.entities.PlaylistEntity
 import com.metrolist.music.db.entities.PlaylistSongMap
 import com.metrolist.music.db.entities.PlaylistSongMapPreview
+import com.metrolist.music.db.entities.RecognitionHistory
 import com.metrolist.music.db.entities.RelatedSongMap
 import com.metrolist.music.db.entities.SearchHistory
 import com.metrolist.music.db.entities.SetVideoIdEntity
@@ -98,14 +99,15 @@ class MusicDatabase(
         Event::class,
         RelatedSongMap::class,
         SetVideoIdEntity::class,
-        PlayCountEntity::class
+        PlayCountEntity::class,
+        RecognitionHistory::class
     ],
     views = [
         SortedSongArtistMap::class,
         SortedSongAlbumMap::class,
         PlaylistSongMapPreview::class,
     ],
-    version = 30,
+    version = 31,
     exportSchema = true,
     autoMigrations = [
         AutoMigration(from = 2, to = 3),
@@ -136,6 +138,7 @@ class MusicDatabase(
         AutoMigration(from = 27, to = 28),
         AutoMigration(from = 28, to = 29),
         AutoMigration(from = 29, to = 30, spec = Migration29To30::class),
+        AutoMigration(from = 30, to = 31),
     ],
 )
 @TypeConverters(Converters::class)
diff --git a/app/src/main/kotlin/com/metrolist/music/db/entities/RecognitionHistory.kt b/app/src/main/kotlin/com/metrolist/music/db/entities/RecognitionHistory.kt
new file mode 100644
index 0000000000..2b1c550029
--- /dev/null
+++ b/app/src/main/kotlin/com/metrolist/music/db/entities/RecognitionHistory.kt
@@ -0,0 +1,40 @@
+/**
+ * Metrolist Project (C) 2026
+ * Licensed under GPL-3.0 | See git history for contributors
+ */
+
+package com.metrolist.music.db.entities
+
+import androidx.room.Entity
+import androidx.room.Index
+import androidx.room.PrimaryKey
+import java.time.LocalDateTime
+
+@Entity(
+    tableName = "recognition_history",
+    indices = [
+        Index(
+            value = ["trackId"],
+            unique = false,
+        ),
+    ],
+)
+data class RecognitionHistory(
+    @PrimaryKey(autoGenerate = true) val id: Long = 0,
+    val trackId: String,
+    val title: String,
+    val artist: String,
+    val album: String? = null,
+    val coverArtUrl: String? = null,
+    val coverArtHqUrl: String? = null,
+    val genre: String? = null,
+    val releaseDate: String? = null,
+    val label: String? = null,
+    val shazamUrl: String? = null,
+    val appleMusicUrl: String? = null,
+    val spotifyUrl: String? = null,
+    val isrc: String? = null,
+    val youtubeVideoId: String? = null,
+    val recognizedAt: LocalDateTime = LocalDateTime.now(),
+    val liked: Boolean = false
+)
diff --git a/app/src/main/kotlin/com/metrolist/music/recognition/AudioResampler.kt b/app/src/main/kotlin/com/metrolist/music/recognition/AudioResampler.kt
new file mode 100644
index 0000000000..9a64572352
--- /dev/null
+++ b/app/src/main/kotlin/com/metrolist/music/recognition/AudioResampler.kt
@@ -0,0 +1,114 @@
+package com.metrolist.music.recognition
+
+import androidx.annotation.OptIn
+import androidx.media3.common.util.UnstableApi
+import androidx.media3.common.audio.AudioProcessor
+import androidx.media3.common.audio.SonicAudioProcessor
+import kotlinx.coroutines.Dispatchers
+import kotlinx.coroutines.ensureActive
+import kotlinx.coroutines.withContext
+import java.nio.ByteBuffer
+import java.nio.ByteOrder
+
+/**
+ * Data class representing decoded audio data with its properties.
+ */
+data class DecodedAudio(
+    val data: ByteArray,
+    val channelCount: Int,
+    val sampleRate: Int,
+    val pcmEncoding: Int,
+) {
+    override fun equals(other: Any?): Boolean {
+        if (this === other) return true
+        if (javaClass != other?.javaClass) return false
+        other as DecodedAudio
+        return data.contentEquals(other.data) &&
+                channelCount == other.channelCount &&
+                sampleRate == other.sampleRate &&
+                pcmEncoding == other.pcmEncoding
+    }
+
+    override fun hashCode(): Int {
+        var result = data.contentHashCode()
+        result = 31 * result + channelCount
+        result = 31 * result + sampleRate
+        result = 31 * result + pcmEncoding
+        return result
+    }
+}
+
+/**
+ * Audio resampler using Media3 SonicAudioProcessor.
+ * Resamples audio to the required sample rate for fingerprinting.
+ */
+@OptIn(UnstableApi::class)
+object AudioResampler {
+
+    suspend fun resample(
+        decodedAudio: DecodedAudio,
+        outputSampleRate: Int
+    ): Result<DecodedAudio> = withContext(Dispatchers.Default) {
+        if (decodedAudio.sampleRate == outputSampleRate) {
+            return@withContext Result.success(decodedAudio)
+        }
+        
+        var sonicRef: AudioProcessor? = null
+        try {
+            val sonic: AudioProcessor = SonicAudioProcessor().apply {
+                setOutputSampleRateHz(outputSampleRate)
+            }
+            sonicRef = sonic
+            
+            val inputFormat = AudioProcessor.AudioFormat(
+                decodedAudio.sampleRate,
+                decodedAudio.channelCount,
+                decodedAudio.pcmEncoding
+            )
+            val outputFormat = sonic.configure(inputFormat)
+            sonic.flush()
+
+            val inputBuf = ByteBuffer.wrap(decodedAudio.data).order(ByteOrder.nativeOrder())
+            sonic.queueInput(inputBuf)
+            sonic.queueEndOfStream()
+
+            val outputChunks = mutableListOf<ByteArray>()
+            var outputChunksByteSize = 0
+
+            while (!sonic.isEnded) {
+                ensureActive()
+                val outputBuffer = sonic.output
+                if (!outputBuffer.hasRemaining()) continue
+                val chunk = ByteArray(outputBuffer.remaining())
+                outputBuffer.get(chunk)
+                outputChunks.add(chunk)
+                outputChunksByteSize += chunk.size
+            }
+            sonic.reset()
+
+            val resampledData = if (outputChunks.size == 1) {
+                outputChunks[0]
+            } else {
+                ByteArray(outputChunksByteSize).also {
+                    var dest = 0
+                    for (chunk in outputChunks) {
+                        System.arraycopy(chunk, 0, it, dest, chunk.size)
+                        dest += chunk.size
+                    }
+                }
+            }
+            
+            Result.success(DecodedAudio(
+                data = resampledData,
+                channelCount = outputFormat.channelCount,
+                sampleRate = outputFormat.sampleRate,
+                pcmEncoding = outputFormat.encoding,
+            ))
+        } catch (e: Exception) {
+            ensureActive()
+            Result.failure(e)
+        } finally {
+            sonicRef?.reset()
+        }
+    }
+}
diff --git a/app/src/main/kotlin/com/metrolist/music/recognition/MusicRecognitionService.kt b/app/src/main/kotlin/com/metrolist/music/recognition/MusicRecognitionService.kt
new file mode 100644
index 0000000000..58a7f23297
--- /dev/null
+++ b/app/src/main/kotlin/com/metrolist/music/recognition/MusicRecognitionService.kt
@@ -0,0 +1,176 @@
+/**
+ * Music Recognition Feature
+ * 
+ * This feature is based on the original MusicRecognizer project by Aleksey Saenko.
+ * Original project: https://github.com/aleksey-saenko/MusicRecognizer
+ * 
+ * Special thanks to Aleksey Saenko for the music recognition implementation.
+ */
+
+package com.metrolist.music.recognition
+
+import android.Manifest
+import android.annotation.SuppressLint
+import android.content.Context
+import android.content.pm.PackageManager
+import android.media.AudioFormat
+import android.media.AudioRecord
+import android.media.MediaRecorder
+import androidx.core.content.ContextCompat
+import com.metrolist.shazamkit.Shazam
+import com.metrolist.shazamkit.models.RecognitionResult
+import com.metrolist.shazamkit.models.RecognitionStatus
+import kotlinx.coroutines.Dispatchers
+import kotlinx.coroutines.flow.MutableStateFlow
+import kotlinx.coroutines.flow.StateFlow
+import kotlinx.coroutines.flow.asStateFlow
+import kotlinx.coroutines.isActive
+import kotlinx.coroutines.withContext
+import java.io.ByteArrayOutputStream
+import java.nio.ByteOrder
+
+/**
+ * Service for recognizing music using audio fingerprinting.
+ * Records audio from the microphone, generates a Shazam-compatible fingerprint,
+ * and sends it to the Shazam API for recognition.
+ */
+object MusicRecognitionService {
+    
+    // Recording parameters
+    private const val RECORDING_SAMPLE_RATE = 44100
+    private const val CHANNEL_CONFIG = AudioFormat.CHANNEL_IN_MONO
+    private const val AUDIO_FORMAT = AudioFormat.ENCODING_PCM_16BIT
+    // Recording duration: 10 seconds for better recognition accuracy
+    // Original MusicRecognizer uses: 3s -> 6s -> 9s -> 10s fallback
+    // We use 10s directly to match the fallback duration for maximum compatibility
+    private const val RECORDING_DURATION_MS = 10000L
+    
+    private val _recognitionStatus = MutableStateFlow<RecognitionStatus>(RecognitionStatus.Ready)
+    val recognitionStatus: StateFlow<RecognitionStatus> = _recognitionStatus.asStateFlow()
+    
+    fun hasRecordPermission(context: Context): Boolean {
+        return ContextCompat.checkSelfPermission(
+            context, 
+            Manifest.permission.RECORD_AUDIO
+        ) == PackageManager.PERMISSION_GRANTED
+    }
+    
+    /**
+     * Start the music recognition process.
+     * Records audio, generates fingerprint, and queries Shazam API.
+     */
+    @SuppressLint("MissingPermission")
+    suspend fun recognize(context: Context): RecognitionStatus = withContext(Dispatchers.IO) {
+        if (!hasRecordPermission(context)) {
+            return@withContext RecognitionStatus.Error("Microphone permission not granted")
+        }
+        
+        _recognitionStatus.value = RecognitionStatus.Listening
+        
+        try {
+            // Step 1: Record audio
+            val audioData = recordAudio()
+            
+            _recognitionStatus.value = RecognitionStatus.Processing
+            
+            // Step 2: Convert to mono if needed and resample to 16kHz
+            val decodedAudio = DecodedAudio(
+                data = audioData,
+                channelCount = 1,
+                sampleRate = RECORDING_SAMPLE_RATE,
+                pcmEncoding = AUDIO_FORMAT
+            )
+            
+            val resampledAudio = AudioResampler.resample(
+                decodedAudio, 
+                VibraSignature.REQUIRED_SAMPLE_RATE
+            ).getOrElse { error ->
+                _recognitionStatus.value = RecognitionStatus.Error("Failed to resample audio: ${error.message}")
+                return@withContext _recognitionStatus.value
+            }
+            
+            // Verify format
+            require(
+                resampledAudio.channelCount == 1 &&
+                resampledAudio.sampleRate == VibraSignature.REQUIRED_SAMPLE_RATE &&
+                resampledAudio.pcmEncoding == AudioFormat.ENCODING_PCM_16BIT &&
+                ByteOrder.nativeOrder() == ByteOrder.LITTLE_ENDIAN &&
+                resampledAudio.data.isNotEmpty() && 
+                resampledAudio.data.size % 2 == 0
+            ) { "Invalid audio format for fingerprint generation" }
+            
+            // Step 3: Generate fingerprint using native library
+            val signature = try {
+                VibraSignature.fromI16(resampledAudio.data)
+            } catch (e: Exception) {
+                _recognitionStatus.value = RecognitionStatus.Error("Failed to generate fingerprint: ${e.message}")
+                return@withContext _recognitionStatus.value
+            }
+            
+            // Step 4: Send to Shazam API
+            val sampleDurationMs = (resampledAudio.data.size / 2) * 1000L / VibraSignature.REQUIRED_SAMPLE_RATE
+            
+            val result = Shazam.recognize(signature, sampleDurationMs)
+            
+            result.fold(
+                onSuccess = { recognitionResult ->
+                    _recognitionStatus.value = RecognitionStatus.Success(recognitionResult)
+                },
+                onFailure = { error ->
+                    val message = error.message ?: "Unknown error"
+                    _recognitionStatus.value = if (message.contains("No match", ignoreCase = true)) {
+                        RecognitionStatus.NoMatch("No matches found. Try again with clearer audio.")
+                    } else {
+                        RecognitionStatus.Error(message)
+                    }
+                }
+            )
+            
+            _recognitionStatus.value
+        } catch (e: Exception) {
+            _recognitionStatus.value = RecognitionStatus.Error(e.message ?: "Recognition failed")
+            _recognitionStatus.value
+        }
+    }
+    
+    @SuppressLint("MissingPermission")
+    private suspend fun recordAudio(): ByteArray = withContext(Dispatchers.IO) {
+        val bufferSize = AudioRecord.getMinBufferSize(
+            RECORDING_SAMPLE_RATE, 
+            CHANNEL_CONFIG, 
+            AUDIO_FORMAT
+        )
+        
+        val audioRecord = AudioRecord(
+            MediaRecorder.AudioSource.MIC,
+            RECORDING_SAMPLE_RATE,
+            CHANNEL_CONFIG,
+            AUDIO_FORMAT,
+            bufferSize
+        )
+        
+        val outputStream = ByteArrayOutputStream()
+        val buffer = ByteArray(bufferSize)
+        val startTime = System.currentTimeMillis()
+        
+        try {
+            audioRecord.startRecording()
+            
+            while (System.currentTimeMillis() - startTime < RECORDING_DURATION_MS && isActive) {
+                val bytesRead = audioRecord.read(buffer, 0, bufferSize)
+                if (bytesRead > 0) {
+                    outputStream.write(buffer, 0, bytesRead)
+                }
+            }
+        } finally {
+            audioRecord.stop()
+            audioRecord.release()
+        }
+        
+        outputStream.toByteArray()
+    }
+    
+    fun reset() {
+        _recognitionStatus.value = RecognitionStatus.Ready
+    }
+}
diff --git a/app/src/main/kotlin/com/metrolist/music/recognition/VibraSignature.kt b/app/src/main/kotlin/com/metrolist/music/recognition/VibraSignature.kt
new file mode 100644
index 0000000000..168c3ff4c3
--- /dev/null
+++ b/app/src/main/kotlin/com/metrolist/music/recognition/VibraSignature.kt
@@ -0,0 +1,24 @@
+package com.metrolist.music.recognition
+
+/**
+ * Native library interface for generating Shazam-compatible audio fingerprints.
+ * Uses the vibra_fp library which implements the Shazam signature algorithm.
+ */
+object VibraSignature {
+
+    init {
+        System.loadLibrary("vibra_fp")
+    }
+
+    const val REQUIRED_SAMPLE_RATE = 16_000
+
+    /**
+     * Generates a Shazam signature from PCM audio data.
+     * 
+     * @param samples Raw PCM audio data (mono, 16-bit signed, 16kHz sample rate)
+     * @return The encoded signature string suitable for Shazam API
+     * @throws RuntimeException if signature generation fails
+     */
+    @JvmStatic
+    external fun fromI16(samples: ByteArray): String
+}
diff --git a/app/src/main/kotlin/com/metrolist/music/ui/component/AppNavigation.kt b/app/src/main/kotlin/com/metrolist/music/ui/component/AppNavigation.kt
index bddcf7a338..5b445c9b6c 100644
--- a/app/src/main/kotlin/com/metrolist/music/ui/component/AppNavigation.kt
+++ b/app/src/main/kotlin/com/metrolist/music/ui/component/AppNavigation.kt
@@ -5,6 +5,7 @@
 
 package com.metrolist.music.ui.component
 
+import androidx.compose.foundation.gestures.detectTapGestures
 import androidx.compose.foundation.layout.Spacer
 import androidx.compose.material3.Icon
 import androidx.compose.material3.MaterialTheme
@@ -19,6 +20,7 @@ import androidx.compose.runtime.Stable
 import androidx.compose.runtime.remember
 import androidx.compose.ui.Modifier
 import androidx.compose.ui.graphics.Color
+import androidx.compose.ui.input.pointer.pointerInput
 import androidx.compose.ui.res.painterResource
 import androidx.compose.ui.res.stringResource
 import androidx.compose.ui.text.style.TextOverflow
@@ -44,7 +46,8 @@ fun AppNavigationRail(
     currentRoute: String?,
     onItemClick: (Screens, Boolean) -> Unit,
     modifier: Modifier = Modifier,
-    pureBlack: Boolean = false
+    pureBlack: Boolean = false,
+    onSearchLongClick: (() -> Unit)? = null
 ) {
     val containerColor = if (pureBlack) Color.Black else MaterialTheme.colorScheme.surfaceContainer
     
@@ -62,13 +65,24 @@ fun AppNavigationRail(
                 if (isSelected) screen.iconIdActive else screen.iconIdInactive
             }
             
+            val itemModifier = if (screen == Screens.Search && onSearchLongClick != null) {
+                Modifier.pointerInput(Unit) {
+                    detectTapGestures(
+                        onLongPress = { onSearchLongClick() }
+                    )
+                }
+            } else {
+                Modifier
+            }
+            
             NavigationRailItem(
                 selected = isSelected,
                 onClick = { onItemClick(screen, isSelected) },
                 icon = {
                     Icon(
                         painter = painterResource(id = iconRes),
-                        contentDescription = stringResource(screen.titleId)
+                        contentDescription = stringResource(screen.titleId),
+                        modifier = itemModifier
                     )
                 }
             )
@@ -85,7 +99,8 @@ fun AppNavigationBar(
     onItemClick: (Screens, Boolean) -> Unit,
     modifier: Modifier = Modifier,
     pureBlack: Boolean = false,
-    slimNav: Boolean = false
+    slimNav: Boolean = false,
+    onSearchLongClick: (() -> Unit)? = null
 ) {
     val containerColor = if (pureBlack) Color.Black else MaterialTheme.colorScheme.surfaceContainer
     val contentColor = if (pureBlack) Color.White else MaterialTheme.colorScheme.onSurfaceVariant
@@ -103,13 +118,24 @@ fun AppNavigationBar(
                 if (isSelected) screen.iconIdActive else screen.iconIdInactive
             }
             
+            val itemModifier = if (screen == Screens.Search && onSearchLongClick != null) {
+                Modifier.pointerInput(Unit) {
+                    detectTapGestures(
+                        onLongPress = { onSearchLongClick() }
+                    )
+                }
+            } else {
+                Modifier
+            }
+            
             NavigationBarItem(
                 selected = isSelected,
                 onClick = { onItemClick(screen, isSelected) },
                 icon = {
                     Icon(
                         painter = painterResource(id = iconRes),
-                        contentDescription = stringResource(screen.titleId)
+                        contentDescription = stringResource(screen.titleId),
+                        modifier = itemModifier
                     )
                 },
                 label = if (!slimNav) {
diff --git a/app/src/main/kotlin/com/metrolist/music/ui/component/HideOnScrollFAB.kt b/app/src/main/kotlin/com/metrolist/music/ui/component/HideOnScrollFAB.kt
index f30e16a6fc..dfef43a597 100644
--- a/app/src/main/kotlin/com/metrolist/music/ui/component/HideOnScrollFAB.kt
+++ b/app/src/main/kotlin/com/metrolist/music/ui/component/HideOnScrollFAB.kt
@@ -11,20 +11,28 @@ import androidx.compose.animation.slideInVertically
 import androidx.compose.animation.slideOutVertically
 import androidx.compose.foundation.ScrollState
 import androidx.compose.foundation.layout.BoxScope
+import androidx.compose.foundation.layout.Column
+import androidx.compose.foundation.layout.Spacer
 import androidx.compose.foundation.layout.WindowInsetsSides
+import androidx.compose.foundation.layout.height
 import androidx.compose.foundation.layout.only
 import androidx.compose.foundation.layout.padding
+import androidx.compose.foundation.layout.size
 import androidx.compose.foundation.layout.windowInsetsPadding
 import androidx.compose.foundation.lazy.LazyListState
 import androidx.compose.foundation.lazy.grid.LazyGridState
 import androidx.compose.material3.FloatingActionButton
 import androidx.compose.material3.Icon
+import androidx.compose.material3.MaterialTheme
+import androidx.compose.material3.SmallFloatingActionButton
 import androidx.compose.runtime.Composable
 import androidx.compose.ui.Alignment
 import androidx.compose.ui.Modifier
 import androidx.compose.ui.res.painterResource
+import androidx.compose.ui.res.stringResource
 import androidx.compose.ui.unit.dp
 import com.metrolist.music.LocalPlayerAwareWindowInsets
+import com.metrolist.music.R
 import com.metrolist.music.ui.utils.isScrollingUp
 
 @Composable
@@ -33,6 +41,7 @@ fun BoxScope.HideOnScrollFAB(
     lazyListState: LazyListState,
     @DrawableRes icon: Int,
     onClick: () -> Unit,
+    onRecognitionClick: (() -> Unit)? = null,
 ) {
     AnimatedVisibility(
         visible = visible && lazyListState.isScrollingUp(),
@@ -46,14 +55,33 @@ fun BoxScope.HideOnScrollFAB(
                     .only(WindowInsetsSides.Bottom + WindowInsetsSides.Horizontal),
             ),
     ) {
-        FloatingActionButton(
-            modifier = Modifier.padding(16.dp),
-            onClick = onClick,
+        Column(
+            horizontalAlignment = Alignment.CenterHorizontally,
+            modifier = Modifier.padding(16.dp)
         ) {
-            Icon(
-                painter = painterResource(icon),
-                contentDescription = null,
-            )
+            if (onRecognitionClick != null) {
+                SmallFloatingActionButton(
+                    onClick = onRecognitionClick,
+                    containerColor = MaterialTheme.colorScheme.secondaryContainer,
+                    contentColor = MaterialTheme.colorScheme.onSecondaryContainer,
+                    modifier = Modifier.size(40.dp)
+                ) {
+                    Icon(
+                        painter = painterResource(R.drawable.mic),
+                        contentDescription = stringResource(R.string.recognize_music),
+                        modifier = Modifier.size(20.dp)
+                    )
+                }
+                Spacer(modifier = Modifier.height(12.dp))
+            }
+            FloatingActionButton(
+                onClick = onClick,
+            ) {
+                Icon(
+                    painter = painterResource(icon),
+                    contentDescription = null,
+                )
+            }
         }
     }
 }
@@ -64,6 +92,7 @@ fun BoxScope.HideOnScrollFAB(
     lazyListState: LazyGridState,
     @DrawableRes icon: Int,
     onClick: () -> Unit,
+    onRecognitionClick: (() -> Unit)? = null,
 ) {
     AnimatedVisibility(
         visible = visible && lazyListState.isScrollingUp(),
@@ -77,14 +106,33 @@ fun BoxScope.HideOnScrollFAB(
                     .only(WindowInsetsSides.Bottom + WindowInsetsSides.Horizontal),
             ),
     ) {
-        FloatingActionButton(
-            modifier = Modifier.padding(16.dp),
-            onClick = onClick,
+        Column(
+            horizontalAlignment = Alignment.CenterHorizontally,
+            modifier = Modifier.padding(16.dp)
         ) {
-            Icon(
-                painter = painterResource(icon),
-                contentDescription = null,
-            )
+            if (onRecognitionClick != null) {
+                SmallFloatingActionButton(
+                    onClick = onRecognitionClick,
+                    containerColor = MaterialTheme.colorScheme.secondaryContainer,
+                    contentColor = MaterialTheme.colorScheme.onSecondaryContainer,
+                    modifier = Modifier.size(40.dp)
+                ) {
+                    Icon(
+                        painter = painterResource(R.drawable.mic),
+                        contentDescription = stringResource(R.string.recognize_music),
+                        modifier = Modifier.size(20.dp)
+                    )
+                }
+                Spacer(modifier = Modifier.height(12.dp))
+            }
+            FloatingActionButton(
+                onClick = onClick,
+            ) {
+                Icon(
+                    painter = painterResource(icon),
+                    contentDescription = null,
+                )
+            }
         }
     }
 }
@@ -95,6 +143,7 @@ fun BoxScope.HideOnScrollFAB(
     scrollState: ScrollState,
     @DrawableRes icon: Int,
     onClick: () -> Unit,
+    onRecognitionClick: (() -> Unit)? = null,
 ) {
     AnimatedVisibility(
         visible = visible && scrollState.isScrollingUp(),
@@ -108,14 +157,33 @@ fun BoxScope.HideOnScrollFAB(
                     .only(WindowInsetsSides.Bottom + WindowInsetsSides.Horizontal),
             ),
     ) {
-        FloatingActionButton(
-            modifier = Modifier.padding(16.dp),
-            onClick = onClick,
+        Column(
+            horizontalAlignment = Alignment.CenterHorizontally,
+            modifier = Modifier.padding(16.dp)
         ) {
-            Icon(
-                painter = painterResource(icon),
-                contentDescription = null,
-            )
+            if (onRecognitionClick != null) {
+                SmallFloatingActionButton(
+                    onClick = onRecognitionClick,
+                    containerColor = MaterialTheme.colorScheme.secondaryContainer,
+                    contentColor = MaterialTheme.colorScheme.onSecondaryContainer,
+                    modifier = Modifier.size(40.dp)
+                ) {
+                    Icon(
+                        painter = painterResource(R.drawable.mic),
+                        contentDescription = stringResource(R.string.recognize_music),
+                        modifier = Modifier.size(20.dp)
+                    )
+                }
+                Spacer(modifier = Modifier.height(12.dp))
+            }
+            FloatingActionButton(
+                onClick = onClick,
+            ) {
+                Icon(
+                    painter = painterResource(icon),
+                    contentDescription = null,
+                )
+            }
         }
     }
 }
diff --git a/app/src/main/kotlin/com/metrolist/music/ui/screens/HomeScreen.kt b/app/src/main/kotlin/com/metrolist/music/ui/screens/HomeScreen.kt
index d355e61b23..53f90f8021 100644
--- a/app/src/main/kotlin/com/metrolist/music/ui/screens/HomeScreen.kt
+++ b/app/src/main/kotlin/com/metrolist/music/ui/screens/HomeScreen.kt
@@ -1065,6 +1065,9 @@ fun HomeScreen(
                         }
                     }
                 }
+            },
+            onRecognitionClick = {
+                navController.navigate("recognition")
             }
         )
 
diff --git a/app/src/main/kotlin/com/metrolist/music/ui/screens/NavigationBuilder.kt b/app/src/main/kotlin/com/metrolist/music/ui/screens/NavigationBuilder.kt
index 118497c196..95b170766a 100644
--- a/app/src/main/kotlin/com/metrolist/music/ui/screens/NavigationBuilder.kt
+++ b/app/src/main/kotlin/com/metrolist/music/ui/screens/NavigationBuilder.kt
@@ -56,6 +56,8 @@ import com.metrolist.music.ui.screens.settings.integrations.DiscordSettings
 import com.metrolist.music.ui.screens.settings.integrations.IntegrationScreen
 import com.metrolist.music.ui.screens.settings.integrations.LastFMSettings
 import com.metrolist.music.ui.screens.settings.integrations.ListenTogetherSettings
+import com.metrolist.music.ui.screens.recognition.RecognitionScreen
+import com.metrolist.music.ui.screens.recognition.RecognitionHistoryScreen
 import com.metrolist.music.ui.screens.wrapped.WrappedScreen
 import com.metrolist.music.utils.rememberEnumPreference
 import com.metrolist.music.utils.rememberPreference
@@ -379,4 +381,12 @@ fun NavGraphBuilder.navigationBuilder(
     dialog("equalizer") {
         EqScreen()
     }
+
+    composable("recognition") {
+        RecognitionScreen(navController)
+    }
+
+    composable("recognition_history") {
+        RecognitionHistoryScreen(navController)
+    }
 }
diff --git a/app/src/main/kotlin/com/metrolist/music/ui/screens/recognition/RecognitionHistoryScreen.kt b/app/src/main/kotlin/com/metrolist/music/ui/screens/recognition/RecognitionHistoryScreen.kt
new file mode 100644
index 0000000000..5293a54bd3
--- /dev/null
+++ b/app/src/main/kotlin/com/metrolist/music/ui/screens/recognition/RecognitionHistoryScreen.kt
@@ -0,0 +1,255 @@
+/**
+ * Metrolist Project (C) 2026
+ * Licensed under GPL-3.0 | See git history for contributors
+ */
+
+package com.metrolist.music.ui.screens.recognition
+
+import androidx.compose.foundation.clickable
+import androidx.compose.foundation.layout.Box
+import androidx.compose.foundation.layout.Column
+import androidx.compose.foundation.layout.Row
+import androidx.compose.foundation.layout.Spacer
+import androidx.compose.foundation.layout.fillMaxSize
+import androidx.compose.foundation.layout.fillMaxWidth
+import androidx.compose.foundation.layout.height
+import androidx.compose.foundation.layout.padding
+import androidx.compose.foundation.layout.size
+import androidx.compose.foundation.layout.width
+import androidx.compose.foundation.lazy.LazyColumn
+import androidx.compose.foundation.lazy.items
+import androidx.compose.foundation.shape.RoundedCornerShape
+import androidx.compose.material3.AlertDialog
+import androidx.compose.material3.Card
+import androidx.compose.material3.CardDefaults
+import androidx.compose.material3.ExperimentalMaterial3Api
+import androidx.compose.material3.Icon
+import androidx.compose.material3.IconButton
+import androidx.compose.material3.MaterialTheme
+import androidx.compose.material3.Scaffold
+import androidx.compose.material3.Text
+import androidx.compose.material3.TextButton
+import androidx.compose.material3.TopAppBar
+import androidx.compose.runtime.Composable
+import androidx.compose.runtime.collectAsState
+import androidx.compose.runtime.getValue
+import androidx.compose.runtime.mutableStateOf
+import androidx.compose.runtime.remember
+import androidx.compose.runtime.rememberCoroutineScope
+import androidx.compose.runtime.setValue
+import androidx.compose.ui.Alignment
+import androidx.compose.ui.Modifier
+import androidx.compose.ui.draw.clip
+import androidx.compose.ui.layout.ContentScale
+import androidx.compose.ui.res.painterResource
+import androidx.compose.ui.res.stringResource
+import androidx.compose.ui.text.font.FontWeight
+import androidx.compose.ui.text.style.TextAlign
+import androidx.compose.ui.text.style.TextOverflow
+import androidx.compose.ui.unit.dp
+import androidx.navigation.NavController
+import coil3.compose.AsyncImage
+import com.metrolist.music.LocalDatabase
+import com.metrolist.music.R
+import com.metrolist.music.db.entities.RecognitionHistory
+import com.metrolist.music.ui.component.IconButton
+import com.metrolist.music.ui.component.LocalMenuState
+import com.metrolist.music.ui.utils.backToMain
+import kotlinx.coroutines.Dispatchers
+import kotlinx.coroutines.launch
+import java.time.format.DateTimeFormatter
+
+@OptIn(ExperimentalMaterial3Api::class)
+@Composable
+fun RecognitionHistoryScreen(
+    navController: NavController
+) {
+    val database = LocalDatabase.current
+    val menuState = LocalMenuState.current
+    val coroutineScope = rememberCoroutineScope()
+    
+    val historyItems by database.recognitionHistory().collectAsState(initial = emptyList())
+    var showClearDialog by remember { mutableStateOf(false) }
+    
+    if (showClearDialog) {
+        AlertDialog(
+            onDismissRequest = { showClearDialog = false },
+            title = { Text(stringResource(R.string.clear_recognition_history)) },
+            text = { Text(stringResource(R.string.clear_recognition_history_confirm)) },
+            confirmButton = {
+                TextButton(
+                    onClick = {
+                        coroutineScope.launch(Dispatchers.IO) {
+                            database.query {
+                                clearRecognitionHistory()
+                            }
+                        }
+                        showClearDialog = false
+                    }
+                ) {
+                    Text(stringResource(R.string.clear))
+                }
+            },
+            dismissButton = {
+                TextButton(onClick = { showClearDialog = false }) {
+                    Text(stringResource(R.string.cancel))
+                }
+            }
+        )
+    }
+    
+    Scaffold(
+        topBar = {
+            TopAppBar(
+                title = { Text(stringResource(R.string.recognition_history)) },
+                navigationIcon = {
+                    IconButton(
+                        onClick = { navController.navigateUp() },
+                        onLongClick = { navController.backToMain() }
+                    ) {
+                        Icon(
+                            painter = painterResource(R.drawable.arrow_back),
+                            contentDescription = null
+                        )
+                    }
+                },
+                actions = {
+                    if (historyItems.isNotEmpty()) {
+                        IconButton(onClick = { showClearDialog = true }) {
+                            Icon(
+                                painter = painterResource(R.drawable.clear_all),
+                                contentDescription = stringResource(R.string.clear_recognition_history)
+                            )
+                        }
+                    }
+                }
+            )
+        }
+    ) { paddingValues ->
+        if (historyItems.isEmpty()) {
+            Box(
+                modifier = Modifier
+                    .fillMaxSize()
+                    .padding(paddingValues),
+                contentAlignment = Alignment.Center
+            ) {
+                Column(
+                    horizontalAlignment = Alignment.CenterHorizontally
+                ) {
+                    Icon(
+                        painter = painterResource(R.drawable.history),
+                        contentDescription = null,
+                        modifier = Modifier.size(64.dp),
+                        tint = MaterialTheme.colorScheme.onSurfaceVariant.copy(alpha = 0.5f)
+                    )
+                    Spacer(modifier = Modifier.height(16.dp))
+                    Text(
+                        text = "No recognition history",
+                        style = MaterialTheme.typography.bodyLarge,
+                        color = MaterialTheme.colorScheme.onSurfaceVariant
+                    )
+                }
+            }
+        } else {
+            LazyColumn(
+                modifier = Modifier
+                    .fillMaxSize()
+                    .padding(paddingValues)
+            ) {
+                items(
+                    items = historyItems,
+                    key = { it.id }
+                ) { item ->
+                    RecognitionHistoryItem(
+                        item = item,
+                        onClick = {
+                            // Search for the track on YouTube Music
+                            val searchQuery = "${item.title} ${item.artist}"
+                            navController.navigate("search/${java.net.URLEncoder.encode(searchQuery, "UTF-8")}")
+                        },
+                        onDelete = {
+                            coroutineScope.launch(Dispatchers.IO) {
+                                database.query {
+                                    deleteRecognitionHistoryById(item.id)
+                                }
+                            }
+                        }
+                    )
+                }
+            }
+        }
+    }
+}
+
+@Composable
+private fun RecognitionHistoryItem(
+    item: RecognitionHistory,
+    onClick: () -> Unit,
+    onDelete: () -> Unit
+) {
+    val dateFormatter = remember { DateTimeFormatter.ofPattern("MMM dd, yyyy HH:mm") }
+    
+    Card(
+        modifier = Modifier
+            .fillMaxWidth()
+            .padding(horizontal = 16.dp, vertical = 8.dp)
+            .clickable { onClick() },
+        shape = RoundedCornerShape(12.dp),
+        colors = CardDefaults.cardColors(
+            containerColor = MaterialTheme.colorScheme.surfaceVariant.copy(alpha = 0.5f)
+        )
+    ) {
+        Row(
+            modifier = Modifier
+                .fillMaxWidth()
+                .padding(12.dp),
+            verticalAlignment = Alignment.CenterVertically
+        ) {
+            // Album art
+            AsyncImage(
+                model = item.coverArtUrl,
+                contentDescription = null,
+                modifier = Modifier
+                    .size(60.dp)
+                    .clip(RoundedCornerShape(8.dp)),
+                contentScale = ContentScale.Crop
+            )
+            
+            Spacer(modifier = Modifier.width(12.dp))
+            
+            // Track info
+            Column(
+                modifier = Modifier.weight(1f)
+            ) {
+                Text(
+                    text = item.title,
+                    style = MaterialTheme.typography.titleMedium,
+                    fontWeight = FontWeight.SemiBold,
+                    maxLines = 1,
+                    overflow = TextOverflow.Ellipsis
+                )
+                Text(
+                    text = item.artist,
+                    style = MaterialTheme.typography.bodyMedium,
+                    color = MaterialTheme.colorScheme.onSurfaceVariant,
+                    maxLines = 1,
+                    overflow = TextOverflow.Ellipsis
+                )
+                Text(
+                    text = item.recognizedAt.format(dateFormatter),
+                    style = MaterialTheme.typography.bodySmall,
+                    color = MaterialTheme.colorScheme.onSurfaceVariant.copy(alpha = 0.7f)
+                )
+            }
+            
+            // Delete action
+            IconButton(onClick = onDelete) {
+                Icon(
+                    painter = painterResource(R.drawable.delete),
+                    contentDescription = stringResource(R.string.delete_from_history),
+                    tint = MaterialTheme.colorScheme.onSurfaceVariant
+                )
+            }
+        }
+    }
+}
diff --git a/app/src/main/kotlin/com/metrolist/music/ui/screens/recognition/RecognitionScreen.kt b/app/src/main/kotlin/com/metrolist/music/ui/screens/recognition/RecognitionScreen.kt
new file mode 100644
index 0000000000..8cef51bc4d
--- /dev/null
+++ b/app/src/main/kotlin/com/metrolist/music/ui/screens/recognition/RecognitionScreen.kt
@@ -0,0 +1,680 @@
+/**
+ * Metrolist Project (C) 2026
+ * Licensed under GPL-3.0 | See git history for contributors
+ */
+
+package com.metrolist.music.ui.screens.recognition
+
+import android.Manifest
+import android.content.pm.PackageManager
+import androidx.activity.compose.rememberLauncherForActivityResult
+import androidx.activity.result.contract.ActivityResultContracts
+import androidx.compose.animation.AnimatedContent
+import androidx.compose.animation.AnimatedVisibility
+import androidx.compose.animation.core.LinearEasing
+import androidx.compose.animation.core.RepeatMode
+import androidx.compose.animation.core.animateFloat
+import androidx.compose.animation.core.infiniteRepeatable
+import androidx.compose.animation.core.rememberInfiniteTransition
+import androidx.compose.animation.core.tween
+import androidx.compose.animation.fadeIn
+import androidx.compose.animation.fadeOut
+import androidx.compose.animation.scaleIn
+import androidx.compose.animation.scaleOut
+import androidx.compose.animation.togetherWith
+import androidx.compose.foundation.background
+import androidx.compose.foundation.border
+import androidx.compose.foundation.clickable
+import androidx.compose.foundation.layout.Arrangement
+import androidx.compose.foundation.layout.Box
+import androidx.compose.foundation.layout.Column
+import androidx.compose.foundation.layout.Row
+import androidx.compose.foundation.layout.Spacer
+import androidx.compose.foundation.layout.aspectRatio
+import androidx.compose.foundation.layout.fillMaxSize
+import androidx.compose.foundation.layout.fillMaxWidth
+import androidx.compose.foundation.layout.height
+import androidx.compose.foundation.layout.padding
+import androidx.compose.foundation.layout.size
+import androidx.compose.foundation.layout.width
+import androidx.compose.foundation.shape.CircleShape
+import androidx.compose.foundation.shape.RoundedCornerShape
+import androidx.compose.material3.Button
+import androidx.compose.material3.ButtonDefaults
+import androidx.compose.material3.Card
+import androidx.compose.material3.CardDefaults
+import androidx.compose.material3.ExperimentalMaterial3Api
+import androidx.compose.material3.FilledTonalButton
+import androidx.compose.material3.Icon
+import androidx.compose.material3.IconButton
+import androidx.compose.material3.MaterialTheme
+import androidx.compose.material3.OutlinedButton
+import androidx.compose.material3.Scaffold
+import androidx.compose.material3.Surface
+import androidx.compose.material3.Text
+import androidx.compose.material3.TopAppBar
+import androidx.compose.runtime.Composable
+import androidx.compose.runtime.DisposableEffect
+import androidx.compose.runtime.LaunchedEffect
+import androidx.compose.runtime.collectAsState
+import androidx.compose.runtime.getValue
+import androidx.compose.runtime.mutableStateOf
+import androidx.compose.runtime.remember
+import androidx.compose.runtime.rememberCoroutineScope
+import androidx.compose.runtime.setValue
+import androidx.compose.ui.Alignment
+import androidx.compose.ui.Modifier
+import androidx.compose.ui.draw.clip
+import androidx.compose.ui.draw.scale
+import androidx.compose.ui.graphics.Brush
+import androidx.compose.ui.graphics.Color
+import androidx.compose.ui.layout.ContentScale
+import androidx.compose.ui.platform.LocalContext
+import androidx.compose.ui.res.painterResource
+import androidx.compose.ui.res.stringResource
+import androidx.compose.ui.text.font.FontWeight
+import androidx.compose.ui.text.style.TextAlign
+import androidx.compose.ui.text.style.TextOverflow
+import androidx.compose.ui.unit.dp
+import androidx.compose.ui.unit.sp
+import androidx.core.content.ContextCompat
+import androidx.navigation.NavController
+import coil3.compose.AsyncImage
+import com.metrolist.music.LocalDatabase
+import com.metrolist.music.R
+import com.metrolist.music.db.entities.RecognitionHistory
+import com.metrolist.music.ui.component.IconButton
+import com.metrolist.music.ui.utils.backToMain
+import com.metrolist.shazamkit.models.RecognitionResult
+import com.metrolist.shazamkit.models.RecognitionStatus
+import kotlinx.coroutines.Dispatchers
+import kotlinx.coroutines.launch
+import java.time.LocalDateTime
+
+@OptIn(ExperimentalMaterial3Api::class)
+@Composable
+fun RecognitionScreen(
+    navController: NavController
+) {
+    val context = LocalContext.current
+    val database = LocalDatabase.current
+    val coroutineScope = rememberCoroutineScope()
+    
+    // Reset recognition status when entering the screen
+    LaunchedEffect(Unit) {
+        com.metrolist.music.recognition.MusicRecognitionService.reset()
+    }
+    
+    // Reset recognition status when leaving the screen
+    DisposableEffect(Unit) {
+        onDispose {
+            com.metrolist.music.recognition.MusicRecognitionService.reset()
+        }
+    }
+    
+    // Observe recognition status from service for real-time updates (Listening -> Processing -> Result)
+    val recognitionStatus by com.metrolist.music.recognition.MusicRecognitionService.recognitionStatus.collectAsState()
+    
+    var hasPermission by remember {
+        mutableStateOf(
+            ContextCompat.checkSelfPermission(context, Manifest.permission.RECORD_AUDIO) 
+                == PackageManager.PERMISSION_GRANTED
+        )
+    }
+    
+    val permissionLauncher = rememberLauncherForActivityResult(
+        contract = ActivityResultContracts.RequestPermission()
+    ) { isGranted ->
+        hasPermission = isGranted
+        if (isGranted) {
+            coroutineScope.launch {
+                com.metrolist.music.recognition.MusicRecognitionService.recognize(context)
+            }
+        }
+    }
+    
+    fun startRecognition() {
+        if (hasPermission) {
+            coroutineScope.launch {
+                com.metrolist.music.recognition.MusicRecognitionService.recognize(context)
+            }
+        } else {
+            permissionLauncher.launch(Manifest.permission.RECORD_AUDIO)
+        }
+    }
+    
+    fun resetToReady() {
+        com.metrolist.music.recognition.MusicRecognitionService.reset()
+    }
+
+    fun saveToHistory(result: RecognitionResult) {
+        coroutineScope.launch(Dispatchers.IO) {
+            database.query {
+                insert(
+                    RecognitionHistory(
+                        trackId = result.trackId,
+                        title = result.title,
+                        artist = result.artist,
+                        album = result.album,
+                        coverArtUrl = result.coverArtUrl,
+                        coverArtHqUrl = result.coverArtHqUrl,
+                        genre = result.genre,
+                        releaseDate = result.releaseDate,
+                        label = result.label,
+                        shazamUrl = result.shazamUrl,
+                        appleMusicUrl = result.appleMusicUrl,
+                        spotifyUrl = result.spotifyUrl,
+                        isrc = result.isrc,
+                        youtubeVideoId = result.youtubeVideoId,
+                        recognizedAt = LocalDateTime.now()
+                    )
+                )
+            }
+        }
+    }
+    
+    Scaffold(
+        topBar = {
+            TopAppBar(
+                title = { Text(stringResource(R.string.recognize_music)) },
+                navigationIcon = {
+                    IconButton(
+                        onClick = { navController.navigateUp() },
+                        onLongClick = { navController.backToMain() }
+                    ) {
+                        Icon(
+                            painter = painterResource(R.drawable.arrow_back),
+                            contentDescription = null
+                        )
+                    }
+                },
+                actions = {
+                    IconButton(onClick = { navController.navigate("recognition_history") }) {
+                        Icon(
+                            painter = painterResource(R.drawable.history),
+                            contentDescription = stringResource(R.string.recognition_history)
+                        )
+                    }
+                }
+            )
+        }
+    ) { paddingValues ->
+        Column(
+            modifier = Modifier
+                .fillMaxSize()
+                .padding(paddingValues)
+                .padding(16.dp),
+            horizontalAlignment = Alignment.CenterHorizontally,
+            verticalArrangement = Arrangement.Center
+        ) {
+            AnimatedContent(
+                targetState = recognitionStatus,
+                transitionSpec = {
+                    (fadeIn() + scaleIn()).togetherWith(fadeOut() + scaleOut())
+                },
+                label = "recognition_content"
+            ) { status ->
+                when (status) {
+                    is RecognitionStatus.Ready -> {
+                        ReadyState(onStartRecognition = ::startRecognition)
+                    }
+                    is RecognitionStatus.Listening -> {
+                        ListeningState(
+                            onCancel = { com.metrolist.music.recognition.MusicRecognitionService.reset() }
+                        )
+                    }
+                    is RecognitionStatus.Processing -> {
+                        ProcessingState()
+                    }
+                    is RecognitionStatus.Success -> {
+                        SuccessState(
+                            result = status.result,
+                            onPlayOnApp = { result ->
+                                // Search for the track on YouTube Music
+                                val searchQuery = "${result.title} ${result.artist}"
+                                navController.navigate("search/${java.net.URLEncoder.encode(searchQuery, "UTF-8")}")
+                            },
+                            onTryAgain = {
+                                startRecognition()
+                            },
+                            onClose = ::resetToReady,
+                            onSaveToHistory = ::saveToHistory
+                        )
+                    }
+                    is RecognitionStatus.NoMatch -> {
+                        NoMatchState(
+                            message = status.message,
+                            onTryAgain = {
+                                startRecognition()
+                            }
+                        )
+                    }
+                    is RecognitionStatus.Error -> {
+                        ErrorState(
+                            message = status.message,
+                            onTryAgain = {
+                                startRecognition()
+                            }
+                        )
+                    }
+                }
+            }
+        }
+    }
+}
+
+@Composable
+private fun ReadyState(
+    onStartRecognition: () -> Unit
+) {
+    Column(
+        horizontalAlignment = Alignment.CenterHorizontally,
+        verticalArrangement = Arrangement.spacedBy(24.dp)
+    ) {
+        Box(
+            modifier = Modifier
+                .size(200.dp)
+                .clip(CircleShape)
+                .background(
+                    Brush.radialGradient(
+                        colors = listOf(
+                            MaterialTheme.colorScheme.primary.copy(alpha = 0.3f),
+                            MaterialTheme.colorScheme.primary.copy(alpha = 0.1f),
+                            Color.Transparent
+                        )
+                    )
+                )
+                .clickable { onStartRecognition() },
+            contentAlignment = Alignment.Center
+        ) {
+            Box(
+                modifier = Modifier
+                    .size(160.dp)
+                    .clip(CircleShape)
+                    .background(MaterialTheme.colorScheme.primary),
+                contentAlignment = Alignment.Center
+            ) {
+                Icon(
+                    painter = painterResource(R.drawable.mic),
+                    contentDescription = null,
+                    modifier = Modifier.size(64.dp),
+                    tint = MaterialTheme.colorScheme.onPrimary
+                )
+            }
+        }
+        
+        Text(
+            text = stringResource(R.string.tap_to_recognize),
+            style = MaterialTheme.typography.titleMedium,
+            color = MaterialTheme.colorScheme.onSurface
+        )
+    }
+}
+
+@Composable
+private fun ListeningState(
+    onCancel: () -> Unit
+) {
+    val infiniteTransition = rememberInfiniteTransition(label = "pulse")
+    val scale by infiniteTransition.animateFloat(
+        initialValue = 1f,
+        targetValue = 1.2f,
+        animationSpec = infiniteRepeatable(
+            animation = tween(1000, easing = LinearEasing),
+            repeatMode = RepeatMode.Reverse
+        ),
+        label = "scale"
+    )
+    
+    Column(
+        horizontalAlignment = Alignment.CenterHorizontally,
+        verticalArrangement = Arrangement.spacedBy(24.dp)
+    ) {
+        // Container large enough for scaled animation (200dp * 1.2 = 240dp)
+        Box(
+            modifier = Modifier.size(260.dp),
+            contentAlignment = Alignment.Center
+        ) {
+            // Outer pulsing ring
+            Box(
+                modifier = Modifier
+                    .size(200.dp)
+                    .scale(scale)
+                    .clip(CircleShape)
+                    .background(MaterialTheme.colorScheme.primary.copy(alpha = 0.2f))
+            )
+            
+            // Inner pulsing ring
+            Box(
+                modifier = Modifier
+                    .size(180.dp)
+                    .scale(scale * 0.9f)
+                    .clip(CircleShape)
+                    .background(MaterialTheme.colorScheme.primary.copy(alpha = 0.3f))
+            )
+            
+            // Main button
+            Box(
+                modifier = Modifier
+                    .size(160.dp)
+                    .clip(CircleShape)
+                    .background(MaterialTheme.colorScheme.primary)
+                    .clickable { onCancel() },
+                contentAlignment = Alignment.Center
+            ) {
+                Icon(
+                    painter = painterResource(R.drawable.mic),
+                    contentDescription = null,
+                    modifier = Modifier.size(64.dp),
+                    tint = MaterialTheme.colorScheme.onPrimary
+                )
+            }
+        }
+        
+        Text(
+            text = stringResource(R.string.listening),
+            style = MaterialTheme.typography.titleMedium,
+            color = MaterialTheme.colorScheme.primary
+        )
+        
+        OutlinedButton(onClick = onCancel) {
+            Text(stringResource(R.string.cancel))
+        }
+    }
+}
+
+@Composable
+private fun ProcessingState() {
+    Column(
+        horizontalAlignment = Alignment.CenterHorizontally,
+        verticalArrangement = Arrangement.spacedBy(24.dp)
+    ) {
+        val infiniteTransition = rememberInfiniteTransition(label = "rotate")
+        val rotation by infiniteTransition.animateFloat(
+            initialValue = 0f,
+            targetValue = 360f,
+            animationSpec = infiniteRepeatable(
+                animation = tween(2000, easing = LinearEasing)
+            ),
+            label = "rotation"
+        )
+        
+        Box(
+            modifier = Modifier.size(160.dp),
+            contentAlignment = Alignment.Center
+        ) {
+            Box(
+                modifier = Modifier
+                    .size(160.dp)
+                    .clip(CircleShape)
+                    .border(
+                        width = 4.dp,
+                        brush = Brush.sweepGradient(
+                            colors = listOf(
+                                MaterialTheme.colorScheme.primary,
+                                MaterialTheme.colorScheme.primary.copy(alpha = 0.5f),
+                                Color.Transparent,
+                                MaterialTheme.colorScheme.primary.copy(alpha = 0.5f),
+                                MaterialTheme.colorScheme.primary
+                            )
+                        ),
+                        shape = CircleShape
+                    )
+            )
+            
+            Icon(
+                painter = painterResource(R.drawable.music_note),
+                contentDescription = null,
+                modifier = Modifier.size(48.dp),
+                tint = MaterialTheme.colorScheme.primary
+            )
+        }
+        
+        Text(
+            text = stringResource(R.string.processing),
+            style = MaterialTheme.typography.titleMedium,
+            color = MaterialTheme.colorScheme.onSurface
+        )
+    }
+}
+
+@Composable
+private fun SuccessState(
+    result: RecognitionResult,
+    onPlayOnApp: (RecognitionResult) -> Unit,
+    onTryAgain: () -> Unit,
+    onClose: () -> Unit,
+    onSaveToHistory: (RecognitionResult) -> Unit
+) {
+    // Save to history when success is shown
+    LaunchedEffect(result) {
+        onSaveToHistory(result)
+    }
+    
+    Column(
+        horizontalAlignment = Alignment.CenterHorizontally,
+        verticalArrangement = Arrangement.spacedBy(16.dp),
+        modifier = Modifier.padding(horizontal = 16.dp)
+    ) {
+        // Album art with close button overlay
+        Box {
+            Card(
+                modifier = Modifier
+                    .size(180.dp)
+                    .aspectRatio(1f),
+                shape = RoundedCornerShape(16.dp),
+                elevation = CardDefaults.cardElevation(defaultElevation = 8.dp)
+            ) {
+                AsyncImage(
+                    model = result.coverArtHqUrl ?: result.coverArtUrl,
+                    contentDescription = null,
+                    modifier = Modifier.fillMaxSize(),
+                    contentScale = ContentScale.Crop
+                )
+            }
+            
+            // Close button - Material 3 Expressive style
+            Surface(
+                onClick = onClose,
+                modifier = Modifier
+                    .align(Alignment.TopEnd)
+                    .padding(8.dp)
+                    .size(32.dp),
+                shape = CircleShape,
+                color = MaterialTheme.colorScheme.surfaceContainerHighest.copy(alpha = 0.9f),
+                contentColor = MaterialTheme.colorScheme.onSurface
+            ) {
+                Box(
+                    contentAlignment = Alignment.Center,
+                    modifier = Modifier.fillMaxSize()
+                ) {
+                    Icon(
+                        painter = painterResource(R.drawable.close),
+                        contentDescription = stringResource(R.string.close),
+                        modifier = Modifier.size(18.dp)
+                    )
+                }
+            }
+        }
+        
+        Spacer(modifier = Modifier.height(8.dp))
+        
+        // Track info
+        Text(
+            text = result.title,
+            style = MaterialTheme.typography.headlineSmall,
+            fontWeight = FontWeight.Bold,
+            textAlign = TextAlign.Center,
+            maxLines = 2,
+            overflow = TextOverflow.Ellipsis
+        )
+        
+        Text(
+            text = result.artist,
+            style = MaterialTheme.typography.titleMedium,
+            color = MaterialTheme.colorScheme.onSurfaceVariant,
+            textAlign = TextAlign.Center,
+            maxLines = 1,
+            overflow = TextOverflow.Ellipsis
+        )
+        
+        result.album?.let { album ->
+            Text(
+                text = album,
+                style = MaterialTheme.typography.bodyMedium,
+                color = MaterialTheme.colorScheme.onSurfaceVariant.copy(alpha = 0.7f),
+                textAlign = TextAlign.Center,
+                maxLines = 1,
+                overflow = TextOverflow.Ellipsis
+            )
+        }
+        
+        Spacer(modifier = Modifier.height(16.dp))
+        
+        // Action buttons - stacked vertically
+        Column(
+            verticalArrangement = Arrangement.spacedBy(12.dp),
+            modifier = Modifier.fillMaxWidth()
+        ) {
+            Button(
+                onClick = { onPlayOnApp(result) },
+                modifier = Modifier.fillMaxWidth()
+            ) {
+                Icon(
+                    painter = painterResource(R.drawable.play),
+                    contentDescription = null,
+                    modifier = Modifier.size(18.dp)
+                )
+                Spacer(modifier = Modifier.width(8.dp))
+                Text(stringResource(R.string.play_on_app))
+            }
+            
+            FilledTonalButton(
+                onClick = onTryAgain,
+                modifier = Modifier.fillMaxWidth()
+            ) {
+                Icon(
+                    painter = painterResource(R.drawable.mic),
+                    contentDescription = null,
+                    modifier = Modifier.size(18.dp)
+                )
+                Spacer(modifier = Modifier.width(8.dp))
+                Text(stringResource(R.string.re_listen))
+            }
+            
+            // Close button - Material 3 Expressive outlined style
+            OutlinedButton(
+                onClick = onClose,
+                modifier = Modifier.fillMaxWidth()
+            ) {
+                Icon(
+                    painter = painterResource(R.drawable.close),
+                    contentDescription = null,
+                    modifier = Modifier.size(18.dp)
+                )
+                Spacer(modifier = Modifier.width(8.dp))
+                Text(stringResource(R.string.close))
+            }
+        }
+    }
+}
+
+@Composable
+private fun NoMatchState(
+    message: String,
+    onTryAgain: () -> Unit
+) {
+    Column(
+        horizontalAlignment = Alignment.CenterHorizontally,
+        verticalArrangement = Arrangement.spacedBy(24.dp)
+    ) {
+        Box(
+            modifier = Modifier
+                .size(120.dp)
+                .clip(CircleShape)
+                .background(MaterialTheme.colorScheme.errorContainer),
+            contentAlignment = Alignment.Center
+        ) {
+            Icon(
+                painter = painterResource(R.drawable.close),
+                contentDescription = null,
+                modifier = Modifier.size(48.dp),
+                tint = MaterialTheme.colorScheme.onErrorContainer
+            )
+        }
+        
+        Text(
+            text = stringResource(R.string.no_match_found),
+            style = MaterialTheme.typography.titleLarge,
+            fontWeight = FontWeight.Bold
+        )
+        
+        Text(
+            text = message,
+            style = MaterialTheme.typography.bodyMedium,
+            color = MaterialTheme.colorScheme.onSurfaceVariant,
+            textAlign = TextAlign.Center,
+            modifier = Modifier.padding(horizontal = 32.dp)
+        )
+        
+        Button(onClick = onTryAgain) {
+            Icon(
+                painter = painterResource(R.drawable.refresh),
+                contentDescription = null,
+                modifier = Modifier.size(18.dp)
+            )
+            Spacer(modifier = Modifier.width(8.dp))
+            Text(stringResource(R.string.try_again))
+        }
+    }
+}
+
+@Composable
+private fun ErrorState(
+    message: String,
+    onTryAgain: () -> Unit
+) {
+    Column(
+        horizontalAlignment = Alignment.CenterHorizontally,
+        verticalArrangement = Arrangement.spacedBy(24.dp)
+    ) {
+        Box(
+            modifier = Modifier
+                .size(120.dp)
+                .clip(CircleShape)
+                .background(MaterialTheme.colorScheme.errorContainer),
+            contentAlignment = Alignment.Center
+        ) {
+            Icon(
+                painter = painterResource(R.drawable.error),
+                contentDescription = null,
+                modifier = Modifier.size(48.dp),
+                tint = MaterialTheme.colorScheme.onErrorContainer
+            )
+        }
+        
+        Text(
+            text = stringResource(R.string.recognition_error),
+            style = MaterialTheme.typography.titleLarge,
+            fontWeight = FontWeight.Bold
+        )
+        
+        Text(
+            text = message,
+            style = MaterialTheme.typography.bodyMedium,
+            color = MaterialTheme.colorScheme.onSurfaceVariant,
+            textAlign = TextAlign.Center,
+            modifier = Modifier.padding(horizontal = 32.dp)
+        )
+        
+        Button(onClick = onTryAgain) {
+            Icon(
+                painter = painterResource(R.drawable.refresh),
+                contentDescription = null,
+                modifier = Modifier.size(18.dp)
+            )
+            Spacer(modifier = Modifier.width(8.dp))
+            Text(stringResource(R.string.try_again))
+        }
+    }
+}
diff --git a/app/src/main/res/drawable/mic.xml b/app/src/main/res/drawable/mic.xml
new file mode 100644
index 0000000000..017b8403ce
--- /dev/null
+++ b/app/src/main/res/drawable/mic.xml
@@ -0,0 +1,9 @@
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="24dp"
+    android:height="24dp"
+    android:viewportWidth="24"
+    android:viewportHeight="24">
+    <path
+        android:fillColor="@android:color/white"
+        android:pathData="M12,14c1.66,0 2.99,-1.34 2.99,-3L15,5c0,-1.66 -1.34,-3 -3,-3S9,3.34 9,5v6c0,1.66 1.34,3 3,3zM17.3,11c0,3 -2.54,5.1 -5.3,5.1S6.7,14 6.7,11L5,11c0,3.41 2.72,6.23 6,6.72L11,21h2v-3.28c3.28,-0.48 6,-3.3 6,-6.72h-1.7z"/>
+</vector>
diff --git a/app/src/main/res/values/metrolist_strings.xml b/app/src/main/res/values/metrolist_strings.xml
index f94fc45efa..5eccab2ced 100644
--- a/app/src/main/res/values/metrolist_strings.xml
+++ b/app/src/main/res/values/metrolist_strings.xml
@@ -631,4 +631,22 @@
     <string name="play_all">Play all</string>
     <string name="enable_high_refresh_rate">Enable high refresh rate</string>
     <string name="enable_high_refresh_rate_desc">Force the display to run at the highest supported refresh rate (e.g. 120Hz)</string>
+
+    <!-- Music Recognition -->
+    <string name="recognition">Recognition</string>
+    <string name="recognize_music">Recognize Music</string>
+    <string name="tap_to_recognize">Tap to recognize</string>
+    <string name="listening">Listening…</string>
+    <string name="processing">Processing…</string>
+    <string name="no_match_found">No match found</string>
+    <string name="recognition_error">Recognition error</string>
+    <string name="try_again">Try again</string>
+    <string name="recognition_history">Recognition History</string>
+    <string name="clear_recognition_history">Clear recognition history</string>
+    <string name="clear_recognition_history_confirm">Are you sure you want to clear all recognition history?</string>
+    <string name="delete_from_history">Delete from history</string>
+    <string name="re_listen">Re-listen</string>
+    <string name="hold_to_recognize">Hold search icon to recognize music</string>
+    <string name="play_on_app">Play on Metrolist</string>
+    <string name="recognized_track">Recognized Track</string>
 </resources>
diff --git a/settings.gradle.kts b/settings.gradle.kts
index 9d1c4e88e2..c49f7f9130 100644
--- a/settings.gradle.kts
+++ b/settings.gradle.kts
@@ -25,6 +25,7 @@ include(":kizzy")
 include(":lastfm")
 include(":betterlyrics")
 include(":simpmusic")
+include(":shazamkit")
 
 // Use a local copy of NewPipe Extractor by uncommenting the lines below.
 // We assume, that Metrolist and NewPipe Extractor have the same parent directory.
diff --git a/shazamkit/build.gradle.kts b/shazamkit/build.gradle.kts
new file mode 100644
index 0000000000..137bb38af7
--- /dev/null
+++ b/shazamkit/build.gradle.kts
@@ -0,0 +1,18 @@
+plugins {
+    alias(libs.plugins.kotlin.serialization)
+    kotlin("jvm")
+}
+
+kotlin {
+    jvmToolchain(21)
+}
+
+dependencies {
+    implementation(libs.ktor.client.core)
+    implementation(libs.ktor.client.okhttp)
+    implementation(libs.ktor.client.cio)
+    implementation(libs.ktor.client.content.negotiation)
+    implementation(libs.ktor.serialization.json)
+    implementation(libs.ktor.client.encoding)
+    testImplementation(libs.junit)
+}
diff --git a/shazamkit/src/main/kotlin/com/metrolist/shazamkit/Shazam.kt b/shazamkit/src/main/kotlin/com/metrolist/shazamkit/Shazam.kt
new file mode 100644
index 0000000000..ab2e076397
--- /dev/null
+++ b/shazamkit/src/main/kotlin/com/metrolist/shazamkit/Shazam.kt
@@ -0,0 +1,145 @@
+package com.metrolist.shazamkit
+
+import com.metrolist.shazamkit.models.RecognitionResult
+import com.metrolist.shazamkit.models.ShazamRequestJson
+import com.metrolist.shazamkit.models.ShazamResponseJson
+import io.ktor.client.HttpClient
+import io.ktor.client.call.body
+import io.ktor.client.engine.cio.CIO
+import io.ktor.client.plugins.contentnegotiation.ContentNegotiation
+import io.ktor.client.request.header
+import io.ktor.client.request.parameter
+import io.ktor.client.request.post
+import io.ktor.client.request.setBody
+import io.ktor.http.ContentType
+import io.ktor.http.contentType
+import io.ktor.serialization.kotlinx.json.json
+import kotlinx.serialization.json.Json
+import java.util.UUID
+import kotlin.random.Random
+
+object Shazam {
+    private val client by lazy {
+        HttpClient(CIO) {
+            install(ContentNegotiation) {
+                json(
+                    Json {
+                        isLenient = true
+                        ignoreUnknownKeys = true
+                    },
+                )
+            }
+            expectSuccess = false
+        }
+    }
+
+    private val userAgents = listOf(
+        "Dalvik/2.1.0 (Linux; U; Android 5.0.2; VS980 4G Build/LRX22G)",
+        "Dalvik/1.6.0 (Linux; U; Android 4.4.2; SM-T210 Build/KOT49H)",
+        "Dalvik/2.1.0 (Linux; U; Android 5.1.1; SM-P905V Build/LMY47X)",
+        "Dalvik/2.1.0 (Linux; U; Android 6.0.1; SM-G920F Build/MMB29K)",
+        "Dalvik/2.1.0 (Linux; U; Android 5.0; SM-G900F Build/LRX21T)"
+    )
+
+    private val timezones = listOf(
+        "Europe/Paris", "Europe/London", "America/New_York",
+        "America/Los_Angeles", "Asia/Tokyo", "Asia/Dubai"
+    )
+
+    /**
+     * Recognize music from an audio signature
+     * The signature should be in Shazam's DejaVu format
+     */
+    suspend fun recognize(signature: String, sampleDurationMs: Long): Result<RecognitionResult> = runCatching {
+        val timestamp = System.currentTimeMillis() / 1000
+        val uuid1 = UUID.randomUUID().toString().uppercase()
+        val uuid2 = UUID.randomUUID().toString()
+        
+        val request = ShazamRequestJson(
+            geolocation = ShazamRequestJson.Geolocation(
+                altitude = Random.nextDouble() * 400 + 100,
+                latitude = Random.nextDouble() * 180 - 90,
+                longitude = Random.nextDouble() * 360 - 180
+            ),
+            signature = ShazamRequestJson.Signature(
+                samplems = sampleDurationMs,
+                timestamp = timestamp,
+                uri = signature
+            ),
+            timestamp = timestamp,
+            timezone = timezones.random()
+        )
+
+        val response = client.post("https://amp.shazam.com/discovery/v5/en/US/android/-/tag/$uuid1/$uuid2") {
+            parameter("sync", "true")
+            parameter("webv3", "true")
+            parameter("sampling", "true")
+            parameter("connected", "")
+            parameter("shazamapiversion", "v3")
+            parameter("sharehub", "true")
+            parameter("video", "v3")
+            header("User-Agent", userAgents.random())
+            header("Content-Language", "en_US")
+            contentType(ContentType.Application.Json)
+            setBody(request)
+        }
+
+        val shazamResponse = response.body<ShazamResponseJson>()
+        shazamResponse.toRecognitionResult() 
+            ?: throw Exception("No match found")
+    }
+
+    /**
+     * Convert Shazam response to our internal model
+     */
+    fun ShazamResponseJson.toRecognitionResult(): RecognitionResult? {
+        val track = this.track ?: return null
+        
+        // Extract metadata from sections
+        val songSection = track.sections?.find { it?.type == "SONG" }
+        val metadata = songSection?.metadata
+        val album = metadata?.find { it?.title == "Album" }?.text
+        val label = metadata?.find { it?.title == "Label" }?.text
+        val releaseDate = metadata?.find { it?.title == "Released" }?.text
+        
+        // Extract lyrics
+        val lyricsSection = track.sections?.find { it?.type == "LYRICS" }
+        val lyrics = lyricsSection?.text
+        
+        // Extract streaming links
+        val appleAction = track.hub?.options?.firstOrNull { 
+            it?.providername?.contains("apple", ignoreCase = true) == true 
+        }?.actions?.firstOrNull()
+        val spotifyProvider = track.hub?.providers?.find { 
+            it?.caption?.contains("spotify", ignoreCase = true) == true 
+        }
+        
+        // Extract YouTube video ID if available
+        val youtubeAction = track.hub?.options?.find { 
+            it?.type?.contains("video", ignoreCase = true) == true 
+        }?.actions?.firstOrNull()
+        val youtubeVideoId = youtubeAction?.uri?.let { uri ->
+            // Extract video ID from YouTube URL or URI
+            uri.substringAfterLast("v=", "").takeIf { it.isNotEmpty() }
+                ?: uri.substringAfterLast("/", "").takeIf { it.isNotEmpty() && it.length == 11 }
+        }
+
+        return RecognitionResult(
+            trackId = track.key ?: tagid ?: "",
+            title = track.title ?: "",
+            artist = track.subtitle ?: "",
+            album = album,
+            coverArtUrl = track.images?.coverart,
+            coverArtHqUrl = track.images?.coverarthq,
+            genre = track.genres?.primary,
+            releaseDate = releaseDate,
+            label = label,
+            lyrics = lyrics,
+            shazamUrl = track.url,
+            appleMusicUrl = appleAction?.uri,
+            spotifyUrl = spotifyProvider?.actions?.firstOrNull()?.uri,
+            isrc = track.isrc,
+            youtubeVideoId = youtubeVideoId
+        )
+    }
+}
diff --git a/shazamkit/src/main/kotlin/com/metrolist/shazamkit/models/ShazamModels.kt b/shazamkit/src/main/kotlin/com/metrolist/shazamkit/models/ShazamModels.kt
new file mode 100644
index 0000000000..ad6f08e789
--- /dev/null
+++ b/shazamkit/src/main/kotlin/com/metrolist/shazamkit/models/ShazamModels.kt
@@ -0,0 +1,317 @@
+package com.metrolist.shazamkit.models
+
+import kotlinx.serialization.SerialName
+import kotlinx.serialization.Serializable
+
+@Serializable
+data class ShazamRequestJson(
+    @SerialName("geolocation")
+    val geolocation: Geolocation,
+    @SerialName("signature")
+    val signature: Signature,
+    @SerialName("timestamp")
+    val timestamp: Long,
+    @SerialName("timezone")
+    val timezone: String
+) {
+    @Serializable
+    data class Geolocation(
+        @SerialName("altitude")
+        val altitude: Double,
+        @SerialName("latitude")
+        val latitude: Double,
+        @SerialName("longitude")
+        val longitude: Double
+    )
+
+    @Serializable
+    data class Signature(
+        @SerialName("samplems")
+        val samplems: Long,
+        @SerialName("timestamp")
+        val timestamp: Long,
+        @SerialName("uri")
+        val uri: String
+    )
+}
+
+@Serializable
+data class ShazamResponseJson(
+    @SerialName("matches")
+    val matches: List<Match?>? = null,
+    @SerialName("location")
+    val location: Location? = null,
+    @SerialName("timestamp")
+    val timestamp: Long? = null,
+    @SerialName("timezone")
+    val timezone: String? = null,
+    @SerialName("track")
+    val track: Track? = null,
+    @SerialName("tagid")
+    val tagid: String? = null
+) {
+    @Serializable
+    data class Match(
+        @SerialName("id")
+        val id: String? = null,
+        @SerialName("offset")
+        val offset: Double? = null,
+        @SerialName("timeskew")
+        val timeskew: Double? = null,
+        @SerialName("frequencyskew")
+        val frequencyskew: Double? = null
+    )
+
+    @Serializable
+    data class Location(
+        @SerialName("latitude")
+        val latitude: Double? = null,
+        @SerialName("longitude")
+        val longitude: Double? = null,
+        @SerialName("altitude")
+        val altitude: Double? = null,
+        @SerialName("accuracy")
+        val accuracy: Double? = null
+    )
+
+    @Serializable
+    data class Track(
+        @SerialName("layout")
+        val layout: String? = null,
+        @SerialName("type")
+        val type: String? = null,
+        @SerialName("key")
+        val key: String? = null,
+        @SerialName("title")
+        val title: String? = null,
+        @SerialName("subtitle")
+        val subtitle: String? = null,
+        @SerialName("images")
+        val images: Images? = null,
+        @SerialName("share")
+        val share: Share? = null,
+        @SerialName("hub")
+        val hub: Hub? = null,
+        @SerialName("sections")
+        val sections: List<Section?>? = null,
+        @SerialName("url")
+        val url: String? = null,
+        @SerialName("artists")
+        val artists: List<Artist?>? = null,
+        @SerialName("isrc")
+        val isrc: String? = null,
+        @SerialName("genres")
+        val genres: Genres? = null,
+        @SerialName("relatedtracksurl")
+        val relatedtracksurl: String? = null,
+        @SerialName("albumadamid")
+        val albumadamid: String? = null
+    ) {
+        @Serializable
+        data class Images(
+            @SerialName("background")
+            val background: String? = null,
+            @SerialName("coverart")
+            val coverart: String? = null,
+            @SerialName("coverarthq")
+            val coverarthq: String? = null,
+            @SerialName("joecolor")
+            val joecolor: String? = null
+        )
+
+        @Serializable
+        data class Share(
+            @SerialName("subject")
+            val subject: String? = null,
+            @SerialName("text")
+            val text: String? = null,
+            @SerialName("href")
+            val href: String? = null,
+            @SerialName("image")
+            val image: String? = null,
+            @SerialName("twitter")
+            val twitter: String? = null,
+            @SerialName("html")
+            val html: String? = null,
+            @SerialName("avatar")
+            val avatar: String? = null,
+            @SerialName("snapchat")
+            val snapchat: String? = null
+        )
+
+        @Serializable
+        data class Hub(
+            @SerialName("type")
+            val type: String? = null,
+            @SerialName("image")
+            val image: String? = null,
+            @SerialName("actions")
+            val actions: List<Action?>? = null,
+            @SerialName("options")
+            val options: List<Option?>? = null,
+            @SerialName("providers")
+            val providers: List<Provider?>? = null,
+            @SerialName("explicit")
+            val explicit: Boolean? = null,
+            @SerialName("displayname")
+            val displayname: String? = null
+        ) {
+            @Serializable
+            data class Action(
+                @SerialName("name")
+                val name: String? = null,
+                @SerialName("type")
+                val type: String? = null,
+                @SerialName("id")
+                val id: String? = null,
+                @SerialName("uri")
+                val uri: String? = null
+            )
+
+            @Serializable
+            data class Option(
+                @SerialName("caption")
+                val caption: String? = null,
+                @SerialName("actions")
+                val actions: List<OptionAction?>? = null,
+                @SerialName("beacondata")
+                val beacondata: Beacondata? = null,
+                @SerialName("image")
+                val image: String? = null,
+                @SerialName("type")
+                val type: String? = null,
+                @SerialName("listcaption")
+                val listcaption: String? = null,
+                @SerialName("overflowimage")
+                val overflowimage: String? = null,
+                @SerialName("colouroverflowimage")
+                val colouroverflowimage: Boolean? = null,
+                @SerialName("providername")
+                val providername: String? = null
+            ) {
+                @Serializable
+                data class OptionAction(
+                    @SerialName("name")
+                    val name: String? = null,
+                    @SerialName("type")
+                    val type: String? = null,
+                    @SerialName("uri")
+                    val uri: String? = null,
+                    @SerialName("id")
+                    val id: String? = null
+                )
+
+                @Serializable
+                data class Beacondata(
+                    @SerialName("type")
+                    val type: String? = null,
+                    @SerialName("providername")
+                    val providername: String? = null
+                )
+            }
+
+            @Serializable
+            data class Provider(
+                @SerialName("caption")
+                val caption: String? = null,
+                @SerialName("images")
+                val images: ProviderImages? = null,
+                @SerialName("actions")
+                val actions: List<ProviderAction?>? = null,
+                @SerialName("type")
+                val type: String? = null
+            ) {
+                @Serializable
+                data class ProviderImages(
+                    @SerialName("overflow")
+                    val overflow: String? = null,
+                    @SerialName("default")
+                    val default: String? = null
+                )
+
+                @Serializable
+                data class ProviderAction(
+                    @SerialName("name")
+                    val name: String? = null,
+                    @SerialName("type")
+                    val type: String? = null,
+                    @SerialName("uri")
+                    val uri: String? = null
+                )
+            }
+        }
+
+        @Serializable
+        data class Section(
+            @SerialName("type")
+            val type: String? = null,
+            @SerialName("metapages")
+            val metapages: List<Metapage?>? = null,
+            @SerialName("tabname")
+            val tabname: String? = null,
+            @SerialName("metadata")
+            val metadata: List<Metadata?>? = null,
+            @SerialName("url")
+            val url: String? = null,
+            @SerialName("text")
+            val text: List<String>? = null,
+        ) {
+            @Serializable
+            data class Metapage(
+                @SerialName("image")
+                val image: String? = null,
+                @SerialName("caption")
+                val caption: String? = null
+            )
+
+            @Serializable
+            data class Metadata(
+                @SerialName("title")
+                val title: String? = null,
+                @SerialName("text")
+                val text: String? = null
+            )
+        }
+
+        @Serializable
+        data class Artist(
+            @SerialName("id")
+            val id: String? = null,
+            @SerialName("adamid")
+            val adamid: String? = null
+        )
+
+        @Serializable
+        data class Genres(
+            @SerialName("primary")
+            val primary: String? = null
+        )
+    }
+}
+
+data class RecognitionResult(
+    val trackId: String,
+    val title: String,
+    val artist: String,
+    val album: String?,
+    val coverArtUrl: String?,
+    val coverArtHqUrl: String?,
+    val genre: String?,
+    val releaseDate: String?,
+    val label: String?,
+    val lyrics: List<String>?,
+    val shazamUrl: String?,
+    val appleMusicUrl: String?,
+    val spotifyUrl: String?,
+    val isrc: String?,
+    val youtubeVideoId: String? = null
+)
+
+sealed class RecognitionStatus {
+    data object Ready : RecognitionStatus()
+    data object Listening : RecognitionStatus()
+    data object Processing : RecognitionStatus()
+    data class Success(val result: RecognitionResult) : RecognitionStatus()
+    data class NoMatch(val message: String = "No matches found") : RecognitionStatus()
+    data class Error(val message: String) : RecognitionStatus()
+}

From 03930b4288e06ebe0dc7150b39b5febfe1840679 Mon Sep 17 00:00:00 2001
From: mostafaalagamy <mostafaalagamy@email.com>
Date: Tue, 10 Feb 2026 23:09:42 +0000
Subject: [PATCH 2/5] feat: Add long press on search tab to open music
 recognition

- Use InteractionSource with LaunchedEffect for proper long press detection
- Single tap on search tab opens search
- Long press on search tab opens music recognition
- Maintains Material 3 design and ripple effects
- Added haptic feedback on long press
- Uses system longPressTimeoutMillis for consistent behavior
---
 .../music/ui/component/AppNavigation.kt       | 102 ++++++++++++++----
 1 file changed, 80 insertions(+), 22 deletions(-)

diff --git a/app/src/main/kotlin/com/metrolist/music/ui/component/AppNavigation.kt b/app/src/main/kotlin/com/metrolist/music/ui/component/AppNavigation.kt
index 5b445c9b6c..e80e6c0b4a 100644
--- a/app/src/main/kotlin/com/metrolist/music/ui/component/AppNavigation.kt
+++ b/app/src/main/kotlin/com/metrolist/music/ui/component/AppNavigation.kt
@@ -5,7 +5,8 @@
 
 package com.metrolist.music.ui.component
 
-import androidx.compose.foundation.gestures.detectTapGestures
+import androidx.compose.foundation.interaction.MutableInteractionSource
+import androidx.compose.foundation.interaction.PressInteraction
 import androidx.compose.foundation.layout.Spacer
 import androidx.compose.material3.Icon
 import androidx.compose.material3.MaterialTheme
@@ -16,15 +17,20 @@ import androidx.compose.material3.NavigationRailItem
 import androidx.compose.material3.Text
 import androidx.compose.runtime.Composable
 import androidx.compose.runtime.Immutable
+import androidx.compose.runtime.LaunchedEffect
 import androidx.compose.runtime.Stable
 import androidx.compose.runtime.remember
 import androidx.compose.ui.Modifier
 import androidx.compose.ui.graphics.Color
-import androidx.compose.ui.input.pointer.pointerInput
+import androidx.compose.ui.hapticfeedback.HapticFeedbackType
+import androidx.compose.ui.platform.LocalHapticFeedback
+import androidx.compose.ui.platform.LocalViewConfiguration
 import androidx.compose.ui.res.painterResource
 import androidx.compose.ui.res.stringResource
 import androidx.compose.ui.text.style.TextOverflow
 import com.metrolist.music.ui.screens.Screens
+import kotlinx.coroutines.delay
+import kotlinx.coroutines.flow.collectLatest
 
 @Immutable
 private data class NavItemState(
@@ -50,6 +56,8 @@ fun AppNavigationRail(
     onSearchLongClick: (() -> Unit)? = null
 ) {
     val containerColor = if (pureBlack) Color.Black else MaterialTheme.colorScheme.surfaceContainer
+    val haptics = LocalHapticFeedback.current
+    val viewConfiguration = LocalViewConfiguration.current
     
     NavigationRail(
         modifier = modifier,
@@ -65,24 +73,48 @@ fun AppNavigationRail(
                 if (isSelected) screen.iconIdActive else screen.iconIdInactive
             }
             
-            val itemModifier = if (screen == Screens.Search && onSearchLongClick != null) {
-                Modifier.pointerInput(Unit) {
-                    detectTapGestures(
-                        onLongPress = { onSearchLongClick() }
-                    )
+            val isSearchItem = screen == Screens.Search && onSearchLongClick != null
+            val interactionSource = remember { MutableInteractionSource() }
+            
+            // Long press detection using InteractionSource
+            if (isSearchItem) {
+                LaunchedEffect(interactionSource) {
+                    var isLongClick = false
+                    interactionSource.interactions.collectLatest { interaction ->
+                        when (interaction) {
+                            is PressInteraction.Press -> {
+                                isLongClick = false
+                                delay(viewConfiguration.longPressTimeoutMillis)
+                                isLongClick = true
+                                haptics.performHapticFeedback(HapticFeedbackType.LongPress)
+                                onSearchLongClick.invoke()
+                            }
+                            is PressInteraction.Release -> {
+                                if (!isLongClick) {
+                                    onItemClick(screen, isSelected)
+                                }
+                            }
+                            is PressInteraction.Cancel -> {
+                                isLongClick = false
+                            }
+                        }
+                    }
                 }
-            } else {
-                Modifier
             }
             
             NavigationRailItem(
                 selected = isSelected,
-                onClick = { onItemClick(screen, isSelected) },
+                onClick = { 
+                    if (!isSearchItem) {
+                        onItemClick(screen, isSelected)
+                    }
+                    // For search item, click is handled via InteractionSource
+                },
+                interactionSource = interactionSource,
                 icon = {
                     Icon(
                         painter = painterResource(id = iconRes),
-                        contentDescription = stringResource(screen.titleId),
-                        modifier = itemModifier
+                        contentDescription = stringResource(screen.titleId)
                     )
                 }
             )
@@ -104,6 +136,8 @@ fun AppNavigationBar(
 ) {
     val containerColor = if (pureBlack) Color.Black else MaterialTheme.colorScheme.surfaceContainer
     val contentColor = if (pureBlack) Color.White else MaterialTheme.colorScheme.onSurfaceVariant
+    val haptics = LocalHapticFeedback.current
+    val viewConfiguration = LocalViewConfiguration.current
     
     NavigationBar(
         modifier = modifier,
@@ -118,24 +152,48 @@ fun AppNavigationBar(
                 if (isSelected) screen.iconIdActive else screen.iconIdInactive
             }
             
-            val itemModifier = if (screen == Screens.Search && onSearchLongClick != null) {
-                Modifier.pointerInput(Unit) {
-                    detectTapGestures(
-                        onLongPress = { onSearchLongClick() }
-                    )
+            val isSearchItem = screen == Screens.Search && onSearchLongClick != null
+            val interactionSource = remember { MutableInteractionSource() }
+            
+            // Long press detection using InteractionSource
+            if (isSearchItem) {
+                LaunchedEffect(interactionSource) {
+                    var isLongClick = false
+                    interactionSource.interactions.collectLatest { interaction ->
+                        when (interaction) {
+                            is PressInteraction.Press -> {
+                                isLongClick = false
+                                delay(viewConfiguration.longPressTimeoutMillis)
+                                isLongClick = true
+                                haptics.performHapticFeedback(HapticFeedbackType.LongPress)
+                                onSearchLongClick.invoke()
+                            }
+                            is PressInteraction.Release -> {
+                                if (!isLongClick) {
+                                    onItemClick(screen, isSelected)
+                                }
+                            }
+                            is PressInteraction.Cancel -> {
+                                isLongClick = false
+                            }
+                        }
+                    }
                 }
-            } else {
-                Modifier
             }
             
             NavigationBarItem(
                 selected = isSelected,
-                onClick = { onItemClick(screen, isSelected) },
+                onClick = { 
+                    if (!isSearchItem) {
+                        onItemClick(screen, isSelected)
+                    }
+                    // For search item, click is handled via InteractionSource
+                },
+                interactionSource = interactionSource,
                 icon = {
                     Icon(
                         painter = painterResource(id = iconRes),
-                        contentDescription = stringResource(screen.titleId),
-                        modifier = itemModifier
+                        contentDescription = stringResource(screen.titleId)
                     )
                 },
                 label = if (!slimNav) {

From 0ae4412369c0971c1776fb2800086e8b167b2525 Mon Sep 17 00:00:00 2001
From: MO AGAMY <mostafaalagamy@email.com>
Date: Wed, 11 Feb 2026 02:47:18 +0200
Subject: [PATCH 3/5] Fix: Kotlin reflection is not available

---
 app/proguard-rules.pro | 24 ++++++++++++++++++++++++
 1 file changed, 24 insertions(+)

diff --git a/app/proguard-rules.pro b/app/proguard-rules.pro
index 0bc15f485d..b82e2736fe 100644
--- a/app/proguard-rules.pro
+++ b/app/proguard-rules.pro
@@ -126,3 +126,27 @@
     native <methods>;
 }
 
+## Kotlin Reflection Fix
+-keep class kotlin.Metadata { *; }
+-keep class kotlin.reflect.** { *; }
+-dontwarn kotlin.reflect.**
+
+## Ktor Serialization
+-keep class io.ktor.** { *; }
+-keepclassmembers class io.ktor.** { *; }
+-dontwarn io.ktor.**
+
+## Shazam Models
+-keep class com.metrolist.shazamkit.models.** { *; }
+-keepclassmembers class com.metrolist.shazamkit.models.** {
+    *;
+}
+
+## Kotlinx Serialization
+-keepattributes *Annotation*
+-keepclassmembers class com.metrolist.shazamkit.models.** {
+    *** Companion;
+}
+-keepclasseswithmembers class com.metrolist.shazamkit.models.** {
+    kotlinx.serialization.KSerializer serializer(...);
+}

From 48bec464c3d7dae10c0e4c0e3239b064c62d187d Mon Sep 17 00:00:00 2001
From: MO AGAMY <mostafaalagamy@email.com>
Date: Wed, 11 Feb 2026 03:05:53 +0200
Subject: [PATCH 4/5] feat: Add rate limiting and queue management to Shazam
 recognition

---
 .../kotlin/com/metrolist/shazamkit/Shazam.kt  | 370 ++++++++++++++++--
 1 file changed, 348 insertions(+), 22 deletions(-)

diff --git a/shazamkit/src/main/kotlin/com/metrolist/shazamkit/Shazam.kt b/shazamkit/src/main/kotlin/com/metrolist/shazamkit/Shazam.kt
index ab2e076397..d60fb97779 100644
--- a/shazamkit/src/main/kotlin/com/metrolist/shazamkit/Shazam.kt
+++ b/shazamkit/src/main/kotlin/com/metrolist/shazamkit/Shazam.kt
@@ -13,12 +13,60 @@ import io.ktor.client.request.post
 import io.ktor.client.request.setBody
 import io.ktor.http.ContentType
 import io.ktor.http.contentType
+import io.ktor.http.isSuccess
 import io.ktor.serialization.kotlinx.json.json
+import kotlinx.coroutines.delay
+import kotlinx.coroutines.sync.Mutex
+import kotlinx.coroutines.sync.withLock
 import kotlinx.serialization.json.Json
 import java.util.UUID
+import java.util.concurrent.ConcurrentHashMap
+import java.util.concurrent.ConcurrentLinkedQueue
+import java.util.concurrent.atomic.AtomicInteger
 import kotlin.random.Random
 
+/**
+ * Shazam music recognition with built-in rate limiting and queue management
+ */
 object Shazam {
+    // ═══════════════════════════════════════════════════════════════
+    // Configuration
+    // ═══════════════════════════════════════════════════════════════
+    
+    private const val MAX_CONCURRENT_REQUESTS = 2
+    
+    private const val MIN_REQUEST_INTERVAL_MS = 1000L
+    
+    private const val MAX_RETRIES = 3
+    
+    private const val INITIAL_RETRY_DELAY_MS = 2000L
+    
+    private const val CACHE_DURATION_MS = 300000L
+    
+    private const val MAX_QUEUE_SIZE = 50
+    
+    // ═══════════════════════════════════════════════════════════════
+    // Internal State
+    // ═══════════════════════════════════════════════════════════════
+    
+    private val activeRequests = AtomicInteger(0)
+    
+    private var lastRequestTime = 0L
+    
+    private val requestMutex = Mutex()
+    
+    private val requestQueue = ConcurrentLinkedQueue<PendingRequest>()
+    
+    private val resultCache = ConcurrentHashMap<String, CachedResult>()
+    
+    private var nextRequestId = 0L
+    
+    private var isProcessingQueue = false
+    
+    // ═══════════════════════════════════════════════════════════════
+    // HTTP Client Configuration
+    // ═══════════════════════════════════════════════════════════════
+    
     private val client by lazy {
         HttpClient(CIO) {
             install(ContentNegotiation) {
@@ -26,10 +74,15 @@ object Shazam {
                     Json {
                         isLenient = true
                         ignoreUnknownKeys = true
+                        encodeDefaults = true
                     },
                 )
             }
             expectSuccess = false
+            
+            engine {
+                requestTimeout = 30000
+            }
         }
     }
 
@@ -46,15 +99,171 @@ object Shazam {
         "America/Los_Angeles", "Asia/Tokyo", "Asia/Dubai"
     )
 
+    // ═══════════════════════════════════════════════════════════════
+    // Public API
+    // ═══════════════════════════════════════════════════════════════
+
+    /**
+     * Recognize music from audio signature
+     * 
+     * @param signature Audio signature in Shazam DejaVu format
+     * @param sampleDurationMs Sample duration in milliseconds
+     * @return Result containing recognition result or error
+     */
+    suspend fun recognize(signature: String, sampleDurationMs: Long): Result<RecognitionResult> {
+        val cacheKey = generateCacheKey(signature)
+        getCachedResult(cacheKey)?.let {
+            return Result.success(it)
+        }
+
+        return enqueueRequest(signature, sampleDurationMs)
+    }
+
+    /**
+     * Get number of pending requests in queue
+     */
+    fun getPendingRequestsCount(): Int = requestQueue.size
+
+    /**
+     * Get number of active requests
+     */
+    fun getActiveRequestsCount(): Int = activeRequests.get()
+
+    /**
+     * Clear cache
+     */
+    fun clearCache() {
+        resultCache.clear()
+    }
+
+    /**
+     * Cancel all pending requests
+     */
+    fun cancelPendingRequests() {
+        requestQueue.clear()
+    }
+
+    /**
+     * Cleanup resources
+     */
+    fun cleanup() {
+        cancelPendingRequests()
+        clearCache()
+        client.close()
+    }
+
+    // ═══════════════════════════════════════════════════════════════
+    // Private Implementation
+    // ═══════════════════════════════════════════════════════════════
+
+    /**
+     * Enqueue request for processing
+     */
+    private suspend fun enqueueRequest(
+        signature: String,
+        sampleDurationMs: Long
+    ): Result<RecognitionResult> = requestMutex.withLock {
+        if (requestQueue.size >= MAX_QUEUE_SIZE) {
+            return Result.failure(Exception("Request queue is full. Please wait."))
+        }
+
+        val requestId = nextRequestId++
+        val request = PendingRequest(
+            id = requestId,
+            signature = signature,
+            sampleDurationMs = sampleDurationMs
+        )
+
+        requestQueue.offer(request)
+
+        if (!isProcessingQueue) {
+            isProcessingQueue = true
+            processQueue()
+        }
+
+        return request.awaitResult()
+    }
+
     /**
-     * Recognize music from an audio signature
-     * The signature should be in Shazam's DejaVu format
+     * Process request queue
      */
-    suspend fun recognize(signature: String, sampleDurationMs: Long): Result<RecognitionResult> = runCatching {
+    private suspend fun processQueue() {
+        while (true) {
+            val request = requestQueue.poll() ?: break
+
+            while (activeRequests.get() >= MAX_CONCURRENT_REQUESTS) {
+                delay(100)
+            }
+
+            activeRequests.incrementAndGet()
+
+            kotlinx.coroutines.GlobalScope.launch {
+                try {
+                    val result = executeRequest(request.signature, request.sampleDurationMs)
+                    request.completeWith(result)
+                } catch (e: Exception) {
+                    request.completeWith(Result.failure(e))
+                } finally {
+                    activeRequests.decrementAndGet()
+                }
+            }
+
+            enforceRateLimit()
+        }
+
+        isProcessingQueue = false
+    }
+
+    /**
+     * Execute recognition request with retry logic
+     */
+    private suspend fun executeRequest(
+        signature: String,
+        sampleDurationMs: Long
+    ): Result<RecognitionResult> {
+        var lastException: Exception? = null
+
+        for (attempt in 0 until MAX_RETRIES) {
+            try {
+                enforceRateLimit()
+                
+                val result = performRecognition(signature, sampleDurationMs)
+                
+                val cacheKey = generateCacheKey(signature)
+                cacheResult(cacheKey, result)
+                
+                return Result.success(result)
+            } catch (e: Exception) {
+                lastException = e
+
+                if (e.message?.contains("429") == true ||
+                    e.message?.contains("Too many requests", ignoreCase = true) == true
+                ) {
+                    if (attempt < MAX_RETRIES - 1) {
+                        val delayTime = calculateBackoffDelay(attempt)
+                        delay(delayTime)
+                        continue
+                    }
+                } else {
+                    throw e
+                }
+            }
+        }
+
+        throw lastException ?: Exception("Recognition failed after $MAX_RETRIES attempts")
+    }
+
+    /**
+     * Perform actual recognition request
+     */
+    private suspend fun performRecognition(
+        signature: String,
+        sampleDurationMs: Long
+    ): RecognitionResult {
         val timestamp = System.currentTimeMillis() / 1000
         val uuid1 = UUID.randomUUID().toString().uppercase()
         val uuid2 = UUID.randomUUID().toString()
-        
+
         val request = ShazamRequestJson(
             geolocation = ShazamRequestJson.Geolocation(
                 altitude = Random.nextDouble() * 400 + 100,
@@ -84,42 +293,122 @@ object Shazam {
             setBody(request)
         }
 
+        if (!response.status.isSuccess()) {
+            val statusCode = response.status.value
+            when (statusCode) {
+                429 -> throw Exception("Too many requests")
+                404 -> throw Exception("No match found")
+                in 500..599 -> throw Exception("Shazam service temporarily unavailable")
+                else -> throw Exception("Recognition failed (error $statusCode)")
+            }
+        }
+
         val shazamResponse = response.body<ShazamResponseJson>()
-        shazamResponse.toRecognitionResult() 
+        return shazamResponse.toRecognitionResult()
             ?: throw Exception("No match found")
     }
 
     /**
-     * Convert Shazam response to our internal model
+     * Enforce minimum time between requests
+     */
+    private suspend fun enforceRateLimit() {
+        val currentTime = System.currentTimeMillis()
+        val timeSinceLastRequest = currentTime - lastRequestTime
+
+        if (timeSinceLastRequest < MIN_REQUEST_INTERVAL_MS) {
+            val delayTime = MIN_REQUEST_INTERVAL_MS - timeSinceLastRequest
+            delay(delayTime)
+        }
+
+        lastRequestTime = System.currentTimeMillis()
+    }
+
+    /**
+     * Calculate delay using Exponential Backoff
+     */
+    private fun calculateBackoffDelay(attempt: Int): Long {
+        return INITIAL_RETRY_DELAY_MS * (1 shl attempt)
+    }
+
+    /**
+     * Generate cache key
+     */
+    private fun generateCacheKey(signature: String): String {
+        return signature.hashCode().toString()
+    }
+
+    /**
+     * Get result from cache
+     */
+    private fun getCachedResult(key: String): RecognitionResult? {
+        val cached = resultCache[key] ?: return null
+        val currentTime = System.currentTimeMillis()
+
+        if (currentTime - cached.timestamp > CACHE_DURATION_MS) {
+            resultCache.remove(key)
+            return null
+        }
+
+        return cached.result
+    }
+
+    /**
+     * Cache result
+     */
+    private fun cacheResult(key: String, result: RecognitionResult) {
+        resultCache[key] = CachedResult(
+            timestamp = System.currentTimeMillis(),
+            result = result
+        )
+
+        cleanupCache()
+    }
+
+    /**
+     * Cleanup expired cache entries
+     */
+    private fun cleanupCache() {
+        if (resultCache.size < 100) return
+
+        val currentTime = System.currentTimeMillis()
+        val iterator = resultCache.entries.iterator()
+
+        while (iterator.hasNext()) {
+            val entry = iterator.next()
+            if (currentTime - entry.value.timestamp > CACHE_DURATION_MS) {
+                iterator.remove()
+            }
+        }
+    }
+
+    /**
+     * Convert Shazam response to internal model
      */
-    fun ShazamResponseJson.toRecognitionResult(): RecognitionResult? {
+    private fun ShazamResponseJson.toRecognitionResult(): RecognitionResult? {
         val track = this.track ?: return null
-        
-        // Extract metadata from sections
+
         val songSection = track.sections?.find { it?.type == "SONG" }
         val metadata = songSection?.metadata
         val album = metadata?.find { it?.title == "Album" }?.text
         val label = metadata?.find { it?.title == "Label" }?.text
         val releaseDate = metadata?.find { it?.title == "Released" }?.text
-        
-        // Extract lyrics
+
         val lyricsSection = track.sections?.find { it?.type == "LYRICS" }
         val lyrics = lyricsSection?.text
-        
-        // Extract streaming links
-        val appleAction = track.hub?.options?.firstOrNull { 
-            it?.providername?.contains("apple", ignoreCase = true) == true 
+
+        val appleAction = track.hub?.options?.firstOrNull {
+            it?.providername?.contains("apple", ignoreCase = true) == true
         }?.actions?.firstOrNull()
-        val spotifyProvider = track.hub?.providers?.find { 
-            it?.caption?.contains("spotify", ignoreCase = true) == true 
-        }
         
-        // Extract YouTube video ID if available
-        val youtubeAction = track.hub?.options?.find { 
-            it?.type?.contains("video", ignoreCase = true) == true 
+        val spotifyProvider = track.hub?.providers?.find {
+            it?.caption?.contains("spotify", ignoreCase = true) == true
+        }
+
+        val youtubeAction = track.hub?.options?.find {
+            it?.type?.contains("video", ignoreCase = true) == true
         }?.actions?.firstOrNull()
+        
         val youtubeVideoId = youtubeAction?.uri?.let { uri ->
-            // Extract video ID from YouTube URL or URI
             uri.substringAfterLast("v=", "").takeIf { it.isNotEmpty() }
                 ?: uri.substringAfterLast("/", "").takeIf { it.isNotEmpty() && it.length == 11 }
         }
@@ -142,4 +431,41 @@ object Shazam {
             youtubeVideoId = youtubeVideoId
         )
     }
+
+    // ═══════════════════════════════════════════════════════════════
+    // Data Classes
+    // ═══════════════════════════════════════════════════════════════
+
+    /**
+     * Pending request in queue
+     */
+    private class PendingRequest(
+        val id: Long,
+        val signature: String,
+        val sampleDurationMs: Long
+    ) {
+        private val mutex = Mutex()
+        private var result: Result<RecognitionResult>? = null
+        private var isCompleted = false
+
+        suspend fun awaitResult(): Result<RecognitionResult> {
+            while (!isCompleted) {
+                delay(50)
+            }
+            return result ?: Result.failure(Exception("Result not received"))
+        }
+
+        fun completeWith(result: Result<RecognitionResult>) {
+            this.result = result
+            this.isCompleted = true
+        }
+    }
+
+    /**
+     * Cached result
+     */
+    private data class CachedResult(
+        val timestamp: Long,
+        val result: RecognitionResult
+    )
 }

From 9a15235e2d961c15a23b81c6924b55435c823e2a Mon Sep 17 00:00:00 2001
From: MO AGAMY <mostafaalagamy@email.com>
Date: Wed, 11 Feb 2026 03:13:29 +0200
Subject: [PATCH 5/5] Fix: Add rate limiting and queue management to Shazam
 recognition

---
 .../kotlin/com/metrolist/shazamkit/Shazam.kt  | 34 ++++++-------------
 1 file changed, 10 insertions(+), 24 deletions(-)

diff --git a/shazamkit/src/main/kotlin/com/metrolist/shazamkit/Shazam.kt b/shazamkit/src/main/kotlin/com/metrolist/shazamkit/Shazam.kt
index d60fb97779..bbf93ea84d 100644
--- a/shazamkit/src/main/kotlin/com/metrolist/shazamkit/Shazam.kt
+++ b/shazamkit/src/main/kotlin/com/metrolist/shazamkit/Shazam.kt
@@ -15,7 +15,11 @@ import io.ktor.http.ContentType
 import io.ktor.http.contentType
 import io.ktor.http.isSuccess
 import io.ktor.serialization.kotlinx.json.json
+import kotlinx.coroutines.CoroutineScope
+import kotlinx.coroutines.Dispatchers
+import kotlinx.coroutines.SupervisorJob
 import kotlinx.coroutines.delay
+import kotlinx.coroutines.launch
 import kotlinx.coroutines.sync.Mutex
 import kotlinx.coroutines.sync.withLock
 import kotlinx.serialization.json.Json
@@ -29,10 +33,10 @@ import kotlin.random.Random
  * Shazam music recognition with built-in rate limiting and queue management
  */
 object Shazam {
-    // ═══════════════════════════════════════════════════════════════
+
+    private val scope = CoroutineScope(Dispatchers.IO + SupervisorJob())
+
     // Configuration
-    // ═══════════════════════════════════════════════════════════════
-    
     private const val MAX_CONCURRENT_REQUESTS = 2
     
     private const val MIN_REQUEST_INTERVAL_MS = 1000L
@@ -44,11 +48,8 @@ object Shazam {
     private const val CACHE_DURATION_MS = 300000L
     
     private const val MAX_QUEUE_SIZE = 50
-    
-    // ═══════════════════════════════════════════════════════════════
+
     // Internal State
-    // ═══════════════════════════════════════════════════════════════
-    
     private val activeRequests = AtomicInteger(0)
     
     private var lastRequestTime = 0L
@@ -62,11 +63,8 @@ object Shazam {
     private var nextRequestId = 0L
     
     private var isProcessingQueue = false
-    
-    // ═══════════════════════════════════════════════════════════════
+
     // HTTP Client Configuration
-    // ═══════════════════════════════════════════════════════════════
-    
     private val client by lazy {
         HttpClient(CIO) {
             install(ContentNegotiation) {
@@ -99,10 +97,6 @@ object Shazam {
         "America/Los_Angeles", "Asia/Tokyo", "Asia/Dubai"
     )
 
-    // ═══════════════════════════════════════════════════════════════
-    // Public API
-    // ═══════════════════════════════════════════════════════════════
-
     /**
      * Recognize music from audio signature
      * 
@@ -152,10 +146,6 @@ object Shazam {
         client.close()
     }
 
-    // ═══════════════════════════════════════════════════════════════
-    // Private Implementation
-    // ═══════════════════════════════════════════════════════════════
-
     /**
      * Enqueue request for processing
      */
@@ -197,7 +187,7 @@ object Shazam {
 
             activeRequests.incrementAndGet()
 
-            kotlinx.coroutines.GlobalScope.launch {
+            scope.launch {
                 try {
                     val result = executeRequest(request.signature, request.sampleDurationMs)
                     request.completeWith(result)
@@ -432,10 +422,6 @@ object Shazam {
         )
     }
 
-    // ═══════════════════════════════════════════════════════════════
-    // Data Classes
-    // ═══════════════════════════════════════════════════════════════
-
     /**
      * Pending request in queue
      */
